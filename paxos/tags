!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACCEPT_ACK_SIZE	./include/libpaxos_messages.h	89;"	d
ACCEPT_REQ_SIZE	./include/libpaxos_messages.h	77;"	d
ACTION	./include/db.h	/^} ACTION;$/;"	t	typeref:enum:__anon25
CHANNEL	./include/db.h	/^struct __channel;	typedef struct __channel CHANNEL;$/;"	t	typeref:struct:__channel
DB	./include/db.h	/^struct __db;		typedef struct __db DB;$/;"	t	typeref:struct:__db
DB2_AM_EXCL	./include/db.h	1842;"	d
DB2_AM_INTEXCL	./include/db.h	1843;"	d
DB2_AM_NOWAIT	./include/db.h	1844;"	d
DBC	./include/db.h	/^struct __dbc;		typedef struct __dbc DBC;$/;"	t	typeref:struct:__dbc
DBC_ACTIVE	./include/db.h	2167;"	d
DBC_BULK	./include/db.h	2168;"	d
DBC_DONTLOCK	./include/db.h	2169;"	d
DBC_DOWNREV	./include/db.h	2170;"	d
DBC_DUPLICATE	./include/db.h	2171;"	d
DBC_ERROR	./include/db.h	2172;"	d
DBC_FAMILY	./include/db.h	2173;"	d
DBC_FROM_DB_GET	./include/db.h	2174;"	d
DBC_INTERNAL	./include/db.h	/^struct __dbc_internal;	typedef struct __dbc_internal DBC_INTERNAL;$/;"	t	typeref:struct:__dbc_internal
DBC_MULTIPLE	./include/db.h	2175;"	d
DBC_MULTIPLE_KEY	./include/db.h	2176;"	d
DBC_OPD	./include/db.h	2177;"	d
DBC_OWN_LID	./include/db.h	2178;"	d
DBC_PARTITIONED	./include/db.h	2179;"	d
DBC_READ_COMMITTED	./include/db.h	2180;"	d
DBC_READ_UNCOMMITTED	./include/db.h	2181;"	d
DBC_RECOVER	./include/db.h	2182;"	d
DBC_RMW	./include/db.h	2183;"	d
DBC_TRANSIENT	./include/db.h	2184;"	d
DBC_WAS_READ_COMMITTED	./include/db.h	2185;"	d
DBC_WRITECURSOR	./include/db.h	2186;"	d
DBC_WRITER	./include/db.h	2187;"	d
DBM	./include/db.h	/^typedef struct __db DBM;$/;"	t	typeref:struct:__db
DBM_INSERT	./include/db.h	2801;"	d
DBM_REPLACE	./include/db.h	2802;"	d
DBM_SUFFIX	./include/db.h	2808;"	d
DBT	./include/db.h	/^struct __db_dbt;	typedef struct __db_dbt DBT;$/;"	t	typeref:struct:__db_dbt
DBTYPE	./include/db.h	/^} DBTYPE;$/;"	t	typeref:enum:__anon13
DB_AFTER	./include/db.h	1344;"	d
DB_AGGRESSIVE	./include/db.h	2882;"	d
DB_ALREADY_ABORTED	./include/db.h	1421;"	d
DB_AM_CHKSUM	./include/db.h	1807;"	d
DB_AM_COMPENSATE	./include/db.h	1808;"	d
DB_AM_COMPRESS	./include/db.h	1809;"	d
DB_AM_CREATED	./include/db.h	1810;"	d
DB_AM_CREATED_MSTR	./include/db.h	1811;"	d
DB_AM_DBM_ERROR	./include/db.h	1812;"	d
DB_AM_DELIMITER	./include/db.h	1813;"	d
DB_AM_DISCARD	./include/db.h	1814;"	d
DB_AM_DUP	./include/db.h	1815;"	d
DB_AM_DUPSORT	./include/db.h	1816;"	d
DB_AM_ENCRYPT	./include/db.h	1817;"	d
DB_AM_FIXEDLEN	./include/db.h	1818;"	d
DB_AM_INMEM	./include/db.h	1819;"	d
DB_AM_INORDER	./include/db.h	1820;"	d
DB_AM_IN_RENAME	./include/db.h	1821;"	d
DB_AM_NOT_DURABLE	./include/db.h	1822;"	d
DB_AM_OPEN_CALLED	./include/db.h	1823;"	d
DB_AM_PAD	./include/db.h	1824;"	d
DB_AM_PARTDB	./include/db.h	1825;"	d
DB_AM_PGDEF	./include/db.h	1826;"	d
DB_AM_RDONLY	./include/db.h	1827;"	d
DB_AM_READ_UNCOMMITTED	./include/db.h	1828;"	d
DB_AM_RECNUM	./include/db.h	1829;"	d
DB_AM_RECOVER	./include/db.h	1830;"	d
DB_AM_RENUMBER	./include/db.h	1831;"	d
DB_AM_REVSPLITOFF	./include/db.h	1832;"	d
DB_AM_SECONDARY	./include/db.h	1833;"	d
DB_AM_SNAPSHOT	./include/db.h	1834;"	d
DB_AM_SUBDB	./include/db.h	1835;"	d
DB_AM_SWAP	./include/db.h	1836;"	d
DB_AM_TXN	./include/db.h	1837;"	d
DB_AM_VERIFYING	./include/db.h	1838;"	d
DB_APPEND	./include/db.h	1345;"	d
DB_ARCH_ABS	./include/db.h	2883;"	d
DB_ARCH_DATA	./include/db.h	2884;"	d
DB_ARCH_LOG	./include/db.h	2885;"	d
DB_ARCH_REMOVE	./include/db.h	2886;"	d
DB_ASSOC_CREATE	./include/db.h	1581;"	d
DB_ASSOC_IMMUTABLE_KEY	./include/db.h	1580;"	d
DB_AUTO_COMMIT	./include/db.h	2887;"	d
DB_BACKUP_CLEAN	./include/db.h	2888;"	d
DB_BACKUP_CONFIG	./include/db.h	/^} DB_BACKUP_CONFIG;$/;"	t	typeref:enum:__anon22
DB_BACKUP_FILES	./include/db.h	2889;"	d
DB_BACKUP_NO_LOGS	./include/db.h	2890;"	d
DB_BACKUP_READ_COUNT	./include/db.h	/^	DB_BACKUP_READ_COUNT=1,$/;"	e	enum:__anon22
DB_BACKUP_READ_SLEEP	./include/db.h	/^	DB_BACKUP_READ_SLEEP=2,$/;"	e	enum:__anon22
DB_BACKUP_SINGLE_DIR	./include/db.h	2891;"	d
DB_BACKUP_SIZE	./include/db.h	/^	DB_BACKUP_SIZE=3,$/;"	e	enum:__anon22
DB_BACKUP_UPDATE	./include/db.h	2892;"	d
DB_BACKUP_WRITE_DIRECT	./include/db.h	/^	DB_BACKUP_WRITE_DIRECT=4$/;"	e	enum:__anon22
DB_BEFORE	./include/db.h	1346;"	d
DB_BOOTSTRAP_HELPER	./include/db.h	2893;"	d
DB_BTREE	./include/db.h	/^	DB_BTREE=1,$/;"	e	enum:__anon13
DB_BTREEMAGIC	./include/db.h	1323;"	d
DB_BTREEOLDVER	./include/db.h	1322;"	d
DB_BTREEVERSION	./include/db.h	1321;"	d
DB_BTREE_STAT	./include/db.h	/^struct __db_bt_stat;	typedef struct __db_bt_stat DB_BTREE_STAT;$/;"	t	typeref:struct:__db_bt_stat
DB_BUFFER_SMALL	./include/db.h	1388;"	d
DB_CACHE_PRIORITY	./include/db.h	/^} DB_CACHE_PRIORITY;$/;"	t	typeref:enum:__anon5
DB_CDB_ALLDB	./include/db.h	2894;"	d
DB_CHANNEL	./include/db.h	/^struct __db_channel;	typedef struct __db_channel DB_CHANNEL;$/;"	t	typeref:struct:__db_channel
DB_CHKSUM	./include/db.h	2895;"	d
DB_CHKSUM_FAIL	./include/db.h	1422;"	d
DB_CIPHER	./include/db.h	/^struct __db_cipher;	typedef struct __db_cipher DB_CIPHER;$/;"	t	typeref:struct:__db_cipher
DB_CKP_INTERNAL	./include/db.h	2896;"	d
DB_COMPACT	./include/db.h	/^struct __db_compact;	typedef struct __db_compact DB_COMPACT;$/;"	t	typeref:struct:__db_compact
DB_CONSUME	./include/db.h	1347;"	d
DB_CONSUME_WAIT	./include/db.h	1348;"	d
DB_CREATE	./include/db.h	2897;"	d
DB_CURRENT	./include/db.h	1349;"	d
DB_CURSOR_BULK	./include/db.h	2898;"	d
DB_CURSOR_TRANSIENT	./include/db.h	2899;"	d
DB_CXX_NO_EXCEPTIONS	./include/db.h	2900;"	d
DB_DATABASE_LOCK	./include/db.h	449;"	d
DB_DATABASE_LOCKING	./include/db.h	2901;"	d
DB_DBT_APPMALLOC	./include/db.h	231;"	d
DB_DBT_BLOB	./include/db.h	243;"	d
DB_DBT_BLOB_REC	./include/db.h	244;"	d
DB_DBT_BULK	./include/db.h	232;"	d
DB_DBT_DUPOK	./include/db.h	233;"	d
DB_DBT_ISSET	./include/db.h	234;"	d
DB_DBT_MALLOC	./include/db.h	235;"	d
DB_DBT_MULTIPLE	./include/db.h	236;"	d
DB_DBT_PARTIAL	./include/db.h	237;"	d
DB_DBT_READONLY	./include/db.h	239;"	d
DB_DBT_REALLOC	./include/db.h	238;"	d
DB_DBT_STREAMING	./include/db.h	240;"	d
DB_DBT_USERCOPY	./include/db.h	241;"	d
DB_DBT_USERMEM	./include/db.h	242;"	d
DB_DEGREE_2	./include/db.h	216;"	d
DB_DELETED	./include/db.h	1423;"	d
DB_DIRECT	./include/db.h	2902;"	d
DB_DIRECT_DB	./include/db.h	2903;"	d
DB_DIRTY_READ	./include/db.h	217;"	d
DB_DISTAB	./include/db.h	/^struct __db_distab;	typedef struct __db_distab DB_DISTAB;$/;"	t	typeref:struct:__db_distab
DB_DONOTINDEX	./include/db.h	1389;"	d
DB_DSYNC_DB	./include/db.h	2904;"	d
DB_DUP	./include/db.h	2905;"	d
DB_DUPSORT	./include/db.h	2906;"	d
DB_DURABLE_UNKNOWN	./include/db.h	2907;"	d
DB_EID_BROADCAST	./include/db.h	1049;"	d
DB_EID_INVALID	./include/db.h	1050;"	d
DB_EID_MASTER	./include/db.h	1051;"	d
DB_ENCRYPT	./include/db.h	2908;"	d
DB_ENCRYPT_AES	./include/db.h	2909;"	d
DB_ENV	./include/db.h	/^struct __db_env;	typedef struct __db_env DB_ENV;$/;"	t	typeref:struct:__db_env
DB_ENV_AUTO_COMMIT	./include/db.h	2459;"	d
DB_ENV_CDB_ALLDB	./include/db.h	2460;"	d
DB_ENV_DATABASE_LOCKING	./include/db.h	2464;"	d
DB_ENV_DIRECT_DB	./include/db.h	2462;"	d
DB_ENV_DSYNC_DB	./include/db.h	2463;"	d
DB_ENV_FAILCHK	./include/db.h	2461;"	d
DB_ENV_HOTBACKUP	./include/db.h	2477;"	d
DB_ENV_MULTIVERSION	./include/db.h	2465;"	d
DB_ENV_NOFLUSH	./include/db.h	2478;"	d
DB_ENV_NOLOCKING	./include/db.h	2466;"	d
DB_ENV_NOMMAP	./include/db.h	2467;"	d
DB_ENV_NOPANIC	./include/db.h	2468;"	d
DB_ENV_OVERWRITE	./include/db.h	2469;"	d
DB_ENV_REGION_INIT	./include/db.h	2470;"	d
DB_ENV_TIME_NOTGRANTED	./include/db.h	2471;"	d
DB_ENV_TXN_NOSYNC	./include/db.h	2472;"	d
DB_ENV_TXN_NOWAIT	./include/db.h	2473;"	d
DB_ENV_TXN_SNAPSHOT	./include/db.h	2474;"	d
DB_ENV_TXN_WRITE_NOSYNC	./include/db.h	2475;"	d
DB_ENV_YIELDCPU	./include/db.h	2476;"	d
DB_EVENT_NOT_HANDLED	./include/db.h	1424;"	d
DB_EVENT_NO_SUCH_EVENT	./include/db.h	1102;"	d
DB_EVENT_PANIC	./include/db.h	1079;"	d
DB_EVENT_REG_ALIVE	./include/db.h	1080;"	d
DB_EVENT_REG_PANIC	./include/db.h	1081;"	d
DB_EVENT_REP_AUTOTAKEOVER_FAILED	./include/db.h	1082;"	d
DB_EVENT_REP_CLIENT	./include/db.h	1083;"	d
DB_EVENT_REP_CONNECT_BROKEN	./include/db.h	1084;"	d
DB_EVENT_REP_CONNECT_ESTD	./include/db.h	1085;"	d
DB_EVENT_REP_CONNECT_TRY_FAILED	./include/db.h	1086;"	d
DB_EVENT_REP_DUPMASTER	./include/db.h	1087;"	d
DB_EVENT_REP_ELECTED	./include/db.h	1088;"	d
DB_EVENT_REP_ELECTION_FAILED	./include/db.h	1089;"	d
DB_EVENT_REP_INIT_DONE	./include/db.h	1090;"	d
DB_EVENT_REP_JOIN_FAILURE	./include/db.h	1091;"	d
DB_EVENT_REP_LOCAL_SITE_REMOVED	./include/db.h	1092;"	d
DB_EVENT_REP_MASTER	./include/db.h	1093;"	d
DB_EVENT_REP_MASTER_FAILURE	./include/db.h	1094;"	d
DB_EVENT_REP_NEWMASTER	./include/db.h	1095;"	d
DB_EVENT_REP_PERM_FAILED	./include/db.h	1096;"	d
DB_EVENT_REP_SITE_ADDED	./include/db.h	1097;"	d
DB_EVENT_REP_SITE_REMOVED	./include/db.h	1098;"	d
DB_EVENT_REP_STARTUPDONE	./include/db.h	1099;"	d
DB_EVENT_REP_WOULD_ROLLBACK	./include/db.h	1100;"	d
DB_EVENT_WRITE_FAILED	./include/db.h	1101;"	d
DB_EXCL	./include/db.h	2910;"	d
DB_EXTENT	./include/db.h	2911;"	d
DB_FAILCHK	./include/db.h	2912;"	d
DB_FAILCHK_ISALIVE	./include/db.h	2913;"	d
DB_FAST_STAT	./include/db.h	2914;"	d
DB_FCNTL_LOCKING	./include/db.h	2915;"	d
DB_FH	./include/db.h	/^struct __fh_t;		typedef struct __fh_t DB_FH;$/;"	t	typeref:struct:__fh_t
DB_FILE_ID_LEN	./include/db.h	289;"	d
DB_FIRST	./include/db.h	1350;"	d
DB_FLUSH	./include/db.h	2916;"	d
DB_FORCE	./include/db.h	2917;"	d
DB_FORCESYNC	./include/db.h	2918;"	d
DB_FOREIGN_ABORT	./include/db.h	2919;"	d
DB_FOREIGN_CASCADE	./include/db.h	2920;"	d
DB_FOREIGN_CONFLICT	./include/db.h	1390;"	d
DB_FOREIGN_NULLIFY	./include/db.h	2921;"	d
DB_FREELIST_ONLY	./include/db.h	2922;"	d
DB_FREE_SPACE	./include/db.h	2923;"	d
DB_GET_BOTH	./include/db.h	1351;"	d
DB_GET_BOTHC	./include/db.h	1352;"	d
DB_GET_BOTH_LTE	./include/db.h	1374;"	d
DB_GET_BOTH_RANGE	./include/db.h	1353;"	d
DB_GET_RECNO	./include/db.h	1354;"	d
DB_GID_SIZE	./include/db.h	979;"	d
DB_GROUP_CREATOR	./include/db.h	2924;"	d
DB_HANDLE_LOCK	./include/db.h	446;"	d
DB_HASH	./include/db.h	/^	DB_HASH=2,$/;"	e	enum:__anon13
DB_HASHMAGIC	./include/db.h	1327;"	d
DB_HASHOLDVER	./include/db.h	1326;"	d
DB_HASHVERSION	./include/db.h	1325;"	d
DB_HASH_STAT	./include/db.h	/^struct __db_h_stat;	typedef struct __db_h_stat DB_HASH_STAT;$/;"	t	typeref:struct:__db_h_stat
DB_HEAP	./include/db.h	/^	DB_HEAP=6,$/;"	e	enum:__anon13
DB_HEAPMAGIC	./include/db.h	1331;"	d
DB_HEAPOLDVER	./include/db.h	1330;"	d
DB_HEAPVERSION	./include/db.h	1329;"	d
DB_HEAP_FULL	./include/db.h	1391;"	d
DB_HEAP_RID	./include/db.h	/^struct __db_heap_rid;	typedef struct __db_heap_rid DB_HEAP_RID;$/;"	t	typeref:struct:__db_heap_rid
DB_HEAP_RID_SZ	./include/db.h	2059;"	d
DB_HEAP_STAT	./include/db.h	/^struct __db_heap_stat;	typedef struct __db_heap_stat DB_HEAP_STAT;$/;"	t	typeref:struct:__db_heap_stat
DB_HOTBACKUP_IN_PROGRESS	./include/db.h	2925;"	d
DB_IGNORE_LEASE	./include/db.h	2926;"	d
DB_IMMUTABLE_KEY	./include/db.h	2927;"	d
DB_INIT_CDB	./include/db.h	2928;"	d
DB_INIT_LOCK	./include/db.h	2929;"	d
DB_INIT_LOG	./include/db.h	2930;"	d
DB_INIT_MPOOL	./include/db.h	2931;"	d
DB_INIT_MUTEX	./include/db.h	2932;"	d
DB_INIT_REP	./include/db.h	2933;"	d
DB_INIT_TXN	./include/db.h	2934;"	d
DB_INORDER	./include/db.h	2935;"	d
DB_INTERNAL_BLOB_DB	./include/db.h	2936;"	d
DB_INTERNAL_PERSISTENT_DB	./include/db.h	2937;"	d
DB_INTERNAL_TEMPORARY_DB	./include/db.h	2938;"	d
DB_JOINENV	./include/db.h	218;"	d
DB_JOIN_ITEM	./include/db.h	1355;"	d
DB_JOIN_NOSORT	./include/db.h	2939;"	d
DB_KEYEMPTY	./include/db.h	1392;"	d
DB_KEYEXIST	./include/db.h	1393;"	d
DB_KEYFIRST	./include/db.h	1356;"	d
DB_KEYLAST	./include/db.h	1357;"	d
DB_KEY_RANGE	./include/db.h	/^struct __key_range;	typedef struct __key_range DB_KEY_RANGE;$/;"	t	typeref:struct:__key_range
DB_LAST	./include/db.h	1358;"	d
DB_LEGACY	./include/db.h	2940;"	d
DB_LOCAL_SITE	./include/db.h	2941;"	d
DB_LOCK	./include/db.h	/^struct __db_lock_u;	typedef struct __db_lock_u DB_LOCK;$/;"	t	typeref:struct:__db_lock_u
DB_LOCKDOWN	./include/db.h	2942;"	d
DB_LOCKER	./include/db.h	/^struct __db_locker;	typedef struct __db_locker DB_LOCKER;$/;"	t	typeref:struct:__db_locker
DB_LOCKREQ	./include/db.h	/^struct __db_lockreq;	typedef struct __db_lockreq DB_LOCKREQ;$/;"	t	typeref:struct:__db_lockreq
DB_LOCKTAB	./include/db.h	/^struct __db_locktab;	typedef struct __db_locktab DB_LOCKTAB;$/;"	t	typeref:struct:__db_locktab
DB_LOCKVERSION	./include/db.h	287;"	d
DB_LOCK_CHECK	./include/db.h	2943;"	d
DB_LOCK_DEADLOCK	./include/db.h	1394;"	d
DB_LOCK_DEFAULT	./include/db.h	296;"	d
DB_LOCK_DUMP	./include/db.h	/^	DB_LOCK_DUMP=0,			\/* Display held locks. *\/$/;"	e	enum:__anon2
DB_LOCK_EXPIRE	./include/db.h	297;"	d
DB_LOCK_GET	./include/db.h	/^	DB_LOCK_GET=1,			\/* Get the lock. *\/$/;"	e	enum:__anon2
DB_LOCK_GET_TIMEOUT	./include/db.h	/^	DB_LOCK_GET_TIMEOUT=2,		\/* Get lock with a timeout. *\/$/;"	e	enum:__anon2
DB_LOCK_HSTAT	./include/db.h	/^struct __db_lock_hstat;	typedef struct __db_lock_hstat DB_LOCK_HSTAT;$/;"	t	typeref:struct:__db_lock_hstat
DB_LOCK_IGNORE_REC	./include/db.h	2944;"	d
DB_LOCK_ILOCK	./include/db.h	/^struct __db_ilock;	typedef struct __db_ilock DB_LOCK_ILOCK;$/;"	t	typeref:struct:__db_ilock
DB_LOCK_INHERIT	./include/db.h	/^	DB_LOCK_INHERIT=3,		\/* Pass locks to parent. *\/$/;"	e	enum:__anon2
DB_LOCK_IREAD	./include/db.h	/^	DB_LOCK_IREAD=5,		\/* Intent to share\/read. *\/$/;"	e	enum:__anon1
DB_LOCK_IWR	./include/db.h	/^	DB_LOCK_IWR=6,			\/* Intent to read and write. *\/$/;"	e	enum:__anon1
DB_LOCK_IWRITE	./include/db.h	/^	DB_LOCK_IWRITE=4,		\/* Intent exclusive\/write. *\/$/;"	e	enum:__anon1
DB_LOCK_MAXLOCKS	./include/db.h	298;"	d
DB_LOCK_MAXWRITE	./include/db.h	299;"	d
DB_LOCK_MINLOCKS	./include/db.h	300;"	d
DB_LOCK_MINWRITE	./include/db.h	301;"	d
DB_LOCK_NG	./include/db.h	/^	DB_LOCK_NG=0,			\/* Not granted. *\/$/;"	e	enum:__anon1
DB_LOCK_NORUN	./include/db.h	295;"	d
DB_LOCK_NOTGRANTED	./include/db.h	1395;"	d
DB_LOCK_NOWAIT	./include/db.h	2945;"	d
DB_LOCK_OLDEST	./include/db.h	302;"	d
DB_LOCK_PSTAT	./include/db.h	/^struct __db_lock_pstat;	typedef struct __db_lock_pstat DB_LOCK_PSTAT;$/;"	t	typeref:struct:__db_lock_pstat
DB_LOCK_PUT	./include/db.h	/^	DB_LOCK_PUT=4,			\/* Release the lock. *\/$/;"	e	enum:__anon2
DB_LOCK_PUT_ALL	./include/db.h	/^	DB_LOCK_PUT_ALL=5,		\/* Release locker's locks. *\/$/;"	e	enum:__anon2
DB_LOCK_PUT_OBJ	./include/db.h	/^	DB_LOCK_PUT_OBJ=6,		\/* Release locker's locks on obj. *\/$/;"	e	enum:__anon2
DB_LOCK_PUT_READ	./include/db.h	/^	DB_LOCK_PUT_READ=7,		\/* Release locker's read locks. *\/$/;"	e	enum:__anon2
DB_LOCK_RANDOM	./include/db.h	303;"	d
DB_LOCK_READ	./include/db.h	/^	DB_LOCK_READ=1,			\/* Shared\/read. *\/$/;"	e	enum:__anon1
DB_LOCK_READ_UNCOMMITTED	./include/db.h	/^	DB_LOCK_READ_UNCOMMITTED=7,	\/* Degree 1 isolation. *\/$/;"	e	enum:__anon1
DB_LOCK_RECORD	./include/db.h	2946;"	d
DB_LOCK_SET_TIMEOUT	./include/db.h	2947;"	d
DB_LOCK_STAT	./include/db.h	/^struct __db_lock_stat;	typedef struct __db_lock_stat DB_LOCK_STAT;$/;"	t	typeref:struct:__db_lock_stat
DB_LOCK_SWITCH	./include/db.h	2948;"	d
DB_LOCK_TIMEOUT	./include/db.h	/^	DB_LOCK_TIMEOUT=8,		\/* Force a txn to timeout. *\/$/;"	e	enum:__anon2
DB_LOCK_TRADE	./include/db.h	/^	DB_LOCK_TRADE=9,		\/* Trade locker ids on a lock. *\/$/;"	e	enum:__anon2
DB_LOCK_UPGRADE	./include/db.h	2949;"	d
DB_LOCK_UPGRADE_WRITE	./include/db.h	/^	DB_LOCK_UPGRADE_WRITE=10	\/* Upgrade writes for dirty reads. *\/$/;"	e	enum:__anon2
DB_LOCK_WAIT	./include/db.h	/^	DB_LOCK_WAIT=3,			\/* Wait for event *\/$/;"	e	enum:__anon1
DB_LOCK_WRITE	./include/db.h	/^	DB_LOCK_WRITE=2,		\/* Exclusive\/write. *\/$/;"	e	enum:__anon1
DB_LOCK_WWRITE	./include/db.h	/^	DB_LOCK_WWRITE=8		\/* Was Written. *\/$/;"	e	enum:__anon1
DB_LOCK_YOUNGEST	./include/db.h	304;"	d
DB_LOG	./include/db.h	/^struct __db_log;	typedef struct __db_log DB_LOG;$/;"	t	typeref:struct:__db_log
DB_LOGC	./include/db.h	/^struct __db_log_cursor;	typedef struct __db_log_cursor DB_LOGC;$/;"	t	typeref:struct:__db_log_cursor
DB_LOGCHKSUM	./include/db.h	480;"	d
DB_LOGFILEID_INVALID	./include/db.h	1473;"	d
DB_LOGMAGIC	./include/db.h	482;"	d
DB_LOGOLDVER	./include/db.h	481;"	d
DB_LOGVERSION	./include/db.h	478;"	d
DB_LOGVERSION_LATCHING	./include/db.h	479;"	d
DB_LOG_AUTO_REMOVE	./include/db.h	2950;"	d
DB_LOG_BLOB	./include/db.h	2951;"	d
DB_LOG_BUFFER_FULL	./include/db.h	1396;"	d
DB_LOG_CHKPNT	./include/db.h	2952;"	d
DB_LOG_COMMIT	./include/db.h	2953;"	d
DB_LOG_DIRECT	./include/db.h	2954;"	d
DB_LOG_DISK	./include/db.h	539;"	d
DB_LOG_DSYNC	./include/db.h	2955;"	d
DB_LOG_IN_MEMORY	./include/db.h	2956;"	d
DB_LOG_LOCKED	./include/db.h	540;"	d
DB_LOG_NOCOPY	./include/db.h	2957;"	d
DB_LOG_NOT_DURABLE	./include/db.h	2958;"	d
DB_LOG_NO_DATA	./include/db.h	2959;"	d
DB_LOG_RECSPEC	./include/db.h	/^} DB_LOG_RECSPEC;$/;"	t	typeref:struct:__log_rec_spec
DB_LOG_SILENT_ERR	./include/db.h	541;"	d
DB_LOG_STAT	./include/db.h	/^struct __db_log_stat;	typedef struct __db_log_stat DB_LOG_STAT;$/;"	t	typeref:struct:__db_log_stat
DB_LOG_VERIFY_BAD	./include/db.h	1397;"	d
DB_LOG_VERIFY_CAF	./include/db.h	2960;"	d
DB_LOG_VERIFY_CONFIG	./include/db.h	/^typedef struct __db_logvrfy_config DB_LOG_VERIFY_CONFIG;$/;"	t	typeref:struct:__db_logvrfy_config
DB_LOG_VERIFY_DBFILE	./include/db.h	2961;"	d
DB_LOG_VERIFY_ERR	./include/db.h	2962;"	d
DB_LOG_VERIFY_FORWARD	./include/db.h	2963;"	d
DB_LOG_VERIFY_INTERR	./include/db.h	2964;"	d
DB_LOG_VERIFY_PARTIAL	./include/db.h	2965;"	d
DB_LOG_VERIFY_VERBOSE	./include/db.h	2966;"	d
DB_LOG_VERIFY_WARNING	./include/db.h	2967;"	d
DB_LOG_WRNOSYNC	./include/db.h	2968;"	d
DB_LOG_ZERO	./include/db.h	2969;"	d
DB_LSN	./include/db.h	/^struct __db_lsn;	typedef struct __db_lsn DB_LSN;$/;"	t	typeref:struct:__db_lsn
DB_LSTAT_ABORTED	./include/db.h	/^	DB_LSTAT_ABORTED=1,		\/* Lock belongs to an aborted txn. *\/$/;"	e	enum:__anon3
DB_LSTAT_EXPIRED	./include/db.h	/^	DB_LSTAT_EXPIRED=2,		\/* Lock has expired. *\/$/;"	e	enum:__anon3
DB_LSTAT_FREE	./include/db.h	/^	DB_LSTAT_FREE=3,		\/* Lock is unallocated. *\/$/;"	e	enum:__anon3
DB_LSTAT_HELD	./include/db.h	/^	DB_LSTAT_HELD=4,		\/* Lock is currently held. *\/$/;"	e	enum:__anon3
DB_LSTAT_PENDING	./include/db.h	/^	DB_LSTAT_PENDING=5,		\/* Lock was waiting and has been$/;"	e	enum:__anon3
DB_LSTAT_WAITING	./include/db.h	/^	DB_LSTAT_WAITING=6		\/* Lock is on the wait queue. *\/$/;"	e	enum:__anon3
DB_MAX_PAGES	./include/db.h	132;"	d
DB_MAX_RECORDS	./include/db.h	135;"	d
DB_MEM_CONFIG	./include/db.h	/^} DB_MEM_CONFIG;$/;"	t	typeref:enum:__anon21
DB_MEM_LOCK	./include/db.h	/^	DB_MEM_LOCK=1,$/;"	e	enum:__anon21
DB_MEM_LOCKER	./include/db.h	/^	DB_MEM_LOCKER=3,$/;"	e	enum:__anon21
DB_MEM_LOCKOBJECT	./include/db.h	/^	DB_MEM_LOCKOBJECT=2,$/;"	e	enum:__anon21
DB_MEM_LOGID	./include/db.h	/^	DB_MEM_LOGID=4,$/;"	e	enum:__anon21
DB_MEM_THREAD	./include/db.h	/^	DB_MEM_THREAD=6$/;"	e	enum:__anon21
DB_MEM_TRANSACTION	./include/db.h	/^	DB_MEM_TRANSACTION=5,$/;"	e	enum:__anon21
DB_MPOOL	./include/db.h	/^struct __db_mpool;	typedef struct __db_mpool DB_MPOOL;$/;"	t	typeref:struct:__db_mpool
DB_MPOOLFILE	./include/db.h	/^struct __db_mpoolfile;	typedef struct __db_mpoolfile DB_MPOOLFILE;$/;"	t	typeref:struct:__db_mpoolfile
DB_MPOOL_CREATE	./include/db.h	2970;"	d
DB_MPOOL_DIRTY	./include/db.h	2971;"	d
DB_MPOOL_DISCARD	./include/db.h	2972;"	d
DB_MPOOL_EDIT	./include/db.h	2973;"	d
DB_MPOOL_FREE	./include/db.h	2974;"	d
DB_MPOOL_FSTAT	./include/db.h	/^struct __db_mpool_fstat;typedef struct __db_mpool_fstat DB_MPOOL_FSTAT;$/;"	t	typeref:struct:__db_mpool_fstat
DB_MPOOL_LAST	./include/db.h	2975;"	d
DB_MPOOL_NEW	./include/db.h	2976;"	d
DB_MPOOL_NOFILE	./include/db.h	2977;"	d
DB_MPOOL_NOLOCK	./include/db.h	2978;"	d
DB_MPOOL_STAT	./include/db.h	/^struct __db_mpool_stat;	typedef struct __db_mpool_stat DB_MPOOL_STAT;$/;"	t	typeref:struct:__db_mpool_stat
DB_MPOOL_TRY	./include/db.h	2979;"	d
DB_MPOOL_UNLINK	./include/db.h	2980;"	d
DB_MULTIPLE	./include/db.h	2981;"	d
DB_MULTIPLE_INIT	./include/db.h	1895;"	d
DB_MULTIPLE_KEY	./include/db.h	2982;"	d
DB_MULTIPLE_KEY_NEXT	./include/db.h	1914;"	d
DB_MULTIPLE_KEY_RESERVE_NEXT	./include/db.h	1981;"	d
DB_MULTIPLE_KEY_WRITE_NEXT	./include/db.h	2004;"	d
DB_MULTIPLE_NEXT	./include/db.h	1899;"	d
DB_MULTIPLE_RECNO_NEXT	./include/db.h	1930;"	d
DB_MULTIPLE_RECNO_RESERVE_NEXT	./include/db.h	2026;"	d
DB_MULTIPLE_RECNO_WRITE_INIT	./include/db.h	2018;"	d
DB_MULTIPLE_RECNO_WRITE_NEXT	./include/db.h	2044;"	d
DB_MULTIPLE_RESERVE_NEXT	./include/db.h	1953;"	d
DB_MULTIPLE_WRITE_INIT	./include/db.h	1945;"	d
DB_MULTIPLE_WRITE_NEXT	./include/db.h	1970;"	d
DB_MULTIVERSION	./include/db.h	2983;"	d
DB_MUTEX	./include/db.h	/^struct __db_mutex_t;	typedef struct __db_mutex_t DB_MUTEX;$/;"	t	typeref:struct:__db_mutex_t
DB_MUTEXMGR	./include/db.h	/^struct __db_mutexmgr;	typedef struct __db_mutexmgr DB_MUTEXMGR;$/;"	t	typeref:struct:__db_mutexmgr
DB_MUTEX_ALLOCATED	./include/db.h	2984;"	d
DB_MUTEX_LOCKED	./include/db.h	2985;"	d
DB_MUTEX_LOGICAL_LOCK	./include/db.h	2986;"	d
DB_MUTEX_PROCESS_ONLY	./include/db.h	2987;"	d
DB_MUTEX_SELF_BLOCK	./include/db.h	2988;"	d
DB_MUTEX_SHARED	./include/db.h	2989;"	d
DB_MUTEX_STAT	./include/db.h	/^struct __db_mutex_stat;	typedef struct __db_mutex_stat DB_MUTEX_STAT;$/;"	t	typeref:struct:__db_mutex_stat
DB_NEEDSPLIT	./include/db.h	1425;"	d
DB_NEXT	./include/db.h	1359;"	d
DB_NEXT_DUP	./include/db.h	1360;"	d
DB_NEXT_NODUP	./include/db.h	1361;"	d
DB_NODUPDATA	./include/db.h	1362;"	d
DB_NOERROR	./include/db.h	2990;"	d
DB_NOFLUSH	./include/db.h	2991;"	d
DB_NOLOCKING	./include/db.h	2992;"	d
DB_NOMMAP	./include/db.h	2993;"	d
DB_NOORDERCHK	./include/db.h	2994;"	d
DB_NOOVERWRITE	./include/db.h	1363;"	d
DB_NOPANIC	./include/db.h	2995;"	d
DB_NOSERVER	./include/db.h	1398;"	d
DB_NOSYNC	./include/db.h	2996;"	d
DB_NOTFOUND	./include/db.h	1399;"	d
DB_NO_AUTO_COMMIT	./include/db.h	2997;"	d
DB_NO_CHECKPOINT	./include/db.h	2998;"	d
DB_ODDFILESIZE	./include/db.h	2999;"	d
DB_OK_BTREE	./include/db.h	1793;"	d
DB_OK_HASH	./include/db.h	1794;"	d
DB_OK_HEAP	./include/db.h	1795;"	d
DB_OK_QUEUE	./include/db.h	1796;"	d
DB_OK_RECNO	./include/db.h	1797;"	d
DB_OLD_VERSION	./include/db.h	1400;"	d
DB_OPFLAGS_MASK	./include/db.h	1377;"	d
DB_ORDERCHKONLY	./include/db.h	3000;"	d
DB_OVERWRITE	./include/db.h	3001;"	d
DB_OVERWRITE_DUP	./include/db.h	1364;"	d
DB_PAGE_LOCK	./include/db.h	448;"	d
DB_PAGE_NOTFOUND	./include/db.h	1401;"	d
DB_PANIC_ENVIRONMENT	./include/db.h	3002;"	d
DB_POSITION	./include/db.h	1365;"	d
DB_PREPLIST	./include/db.h	/^struct __db_preplist;	typedef struct __db_preplist DB_PREPLIST;$/;"	t	typeref:struct:__db_preplist
DB_PREV	./include/db.h	1366;"	d
DB_PREV_DUP	./include/db.h	1367;"	d
DB_PREV_NODUP	./include/db.h	1368;"	d
DB_PRINTABLE	./include/db.h	3003;"	d
DB_PRIORITY_DEFAULT	./include/db.h	/^	DB_PRIORITY_DEFAULT=3,$/;"	e	enum:__anon5
DB_PRIORITY_HIGH	./include/db.h	/^	DB_PRIORITY_HIGH=4,$/;"	e	enum:__anon5
DB_PRIORITY_LOW	./include/db.h	/^	DB_PRIORITY_LOW=2,$/;"	e	enum:__anon5
DB_PRIORITY_UNCHANGED	./include/db.h	/^	DB_PRIORITY_UNCHANGED=0,$/;"	e	enum:__anon5
DB_PRIORITY_VERY_HIGH	./include/db.h	/^	DB_PRIORITY_VERY_HIGH=5$/;"	e	enum:__anon5
DB_PRIORITY_VERY_LOW	./include/db.h	/^	DB_PRIORITY_VERY_LOW=1,$/;"	e	enum:__anon5
DB_PRIVATE	./include/db.h	3004;"	d
DB_PR_PAGE	./include/db.h	3005;"	d
DB_PR_RECOVERYTEST	./include/db.h	3006;"	d
DB_QAMMAGIC	./include/db.h	1335;"	d
DB_QAMOLDVER	./include/db.h	1334;"	d
DB_QAMVERSION	./include/db.h	1333;"	d
DB_QUEUE	./include/db.h	/^	DB_QUEUE=4,$/;"	e	enum:__anon13
DB_QUEUE_STAT	./include/db.h	/^struct __db_qam_stat;	typedef struct __db_qam_stat DB_QUEUE_STAT;$/;"	t	typeref:struct:__db_qam_stat
DB_RDONLY	./include/db.h	3007;"	d
DB_RDWRMASTER	./include/db.h	3008;"	d
DB_READ_COMMITTED	./include/db.h	3009;"	d
DB_READ_UNCOMMITTED	./include/db.h	3010;"	d
DB_RECNO	./include/db.h	/^	DB_RECNO=3,$/;"	e	enum:__anon13
DB_RECNUM	./include/db.h	3011;"	d
DB_RECORD_LOCK	./include/db.h	447;"	d
DB_RECOVER	./include/db.h	3012;"	d
DB_RECOVER_FATAL	./include/db.h	3013;"	d
DB_REDO	./include/db.h	821;"	d
DB_REGION_INIT	./include/db.h	3014;"	d
DB_REGION_MAGIC	./include/db.h	2295;"	d
DB_REGISTER	./include/db.h	3015;"	d
DB_RENAMEMAGIC	./include/db.h	1319;"	d
DB_RENUMBER	./include/db.h	3016;"	d
DB_REP	./include/db.h	/^struct __db_rep;	typedef struct __db_rep DB_REP;$/;"	t	typeref:struct:__db_rep
DB_REPMGR_ACKS_ALL	./include/db.h	1056;"	d
DB_REPMGR_ACKS_ALL_AVAILABLE	./include/db.h	1057;"	d
DB_REPMGR_ACKS_ALL_PEERS	./include/db.h	1058;"	d
DB_REPMGR_ACKS_NONE	./include/db.h	1059;"	d
DB_REPMGR_ACKS_ONE	./include/db.h	1060;"	d
DB_REPMGR_ACKS_ONE_PEER	./include/db.h	1061;"	d
DB_REPMGR_ACKS_QUORUM	./include/db.h	1062;"	d
DB_REPMGR_CONF_2SITE_STRICT	./include/db.h	3017;"	d
DB_REPMGR_CONF_ELECTIONS	./include/db.h	3018;"	d
DB_REPMGR_CONNECTED	./include/db.h	1110;"	d
DB_REPMGR_CONN_ERR	./include/db.h	/^	typedef struct __db_repmgr_conn_err DB_REPMGR_CONN_ERR;$/;"	t	typeref:struct:__db_repmgr_conn_err
DB_REPMGR_DISCONNECTED	./include/db.h	1111;"	d
DB_REPMGR_ISPEER	./include/db.h	1114;"	d
DB_REPMGR_ISVIEW	./include/db.h	1115;"	d
DB_REPMGR_NEED_RESPONSE	./include/db.h	3019;"	d
DB_REPMGR_PEER	./include/db.h	3020;"	d
DB_REPMGR_SITE	./include/db.h	/^struct __db_repmgr_site;typedef struct __db_repmgr_site DB_REPMGR_SITE;$/;"	t	typeref:struct:__db_repmgr_site
DB_REPMGR_STAT	./include/db.h	/^struct __db_repmgr_stat;typedef struct __db_repmgr_stat DB_REPMGR_STAT;$/;"	t	typeref:struct:__db_repmgr_stat
DB_REP_ACK_TIMEOUT	./include/db.h	1065;"	d
DB_REP_ANYWHERE	./include/db.h	3021;"	d
DB_REP_BULKOVF	./include/db.h	1426;"	d
DB_REP_CHECKPOINT_DELAY	./include/db.h	1066;"	d
DB_REP_CLIENT	./include/db.h	3022;"	d
DB_REP_CONF_AUTOINIT	./include/db.h	3023;"	d
DB_REP_CONF_AUTOROLLBACK	./include/db.h	3024;"	d
DB_REP_CONF_BULK	./include/db.h	3025;"	d
DB_REP_CONF_DELAYCLIENT	./include/db.h	3026;"	d
DB_REP_CONF_INMEM	./include/db.h	3027;"	d
DB_REP_CONF_LEASE	./include/db.h	3028;"	d
DB_REP_CONF_NOWAIT	./include/db.h	3029;"	d
DB_REP_CONNECTION_RETRY	./include/db.h	1067;"	d
DB_REP_DEFAULT_PRIORITY	./include/db.h	1053;"	d
DB_REP_DUPMASTER	./include/db.h	1402;"	d
DB_REP_ELECTION	./include/db.h	3030;"	d
DB_REP_ELECTION_RETRY	./include/db.h	1068;"	d
DB_REP_ELECTION_TIMEOUT	./include/db.h	1069;"	d
DB_REP_FULL_ELECTION_TIMEOUT	./include/db.h	1070;"	d
DB_REP_HANDLE_DEAD	./include/db.h	1403;"	d
DB_REP_HEARTBEAT_MONITOR	./include/db.h	1071;"	d
DB_REP_HEARTBEAT_SEND	./include/db.h	1072;"	d
DB_REP_HOLDELECTION	./include/db.h	1404;"	d
DB_REP_IGNORE	./include/db.h	1405;"	d
DB_REP_ISPERM	./include/db.h	1406;"	d
DB_REP_JOIN_FAILURE	./include/db.h	1407;"	d
DB_REP_LEASE_EXPIRED	./include/db.h	1408;"	d
DB_REP_LEASE_TIMEOUT	./include/db.h	1073;"	d
DB_REP_LOCKOUT	./include/db.h	1409;"	d
DB_REP_LOGREADY	./include/db.h	1427;"	d
DB_REP_MASTER	./include/db.h	3031;"	d
DB_REP_NEWMASTER	./include/db.h	1428;"	d
DB_REP_NEWSITE	./include/db.h	1410;"	d
DB_REP_NOBUFFER	./include/db.h	3032;"	d
DB_REP_NOTPERM	./include/db.h	1411;"	d
DB_REP_PAGEDONE	./include/db.h	1429;"	d
DB_REP_PERMANENT	./include/db.h	3033;"	d
DB_REP_REREQUEST	./include/db.h	3034;"	d
DB_REP_STAT	./include/db.h	/^struct __db_rep_stat;	typedef struct __db_rep_stat DB_REP_STAT;$/;"	t	typeref:struct:__db_rep_stat
DB_REP_UNAVAIL	./include/db.h	1412;"	d
DB_REP_WOULDROLLBACK	./include/db.h	1413;"	d
DB_REVSPLITOFF	./include/db.h	3035;"	d
DB_RMW	./include/db.h	3036;"	d
DB_RUNRECOVERY	./include/db.h	1414;"	d
DB_SALVAGE	./include/db.h	3037;"	d
DB_SA_SKIPFIRSTKEY	./include/db.h	3038;"	d
DB_SA_UNKNOWNKEY	./include/db.h	3039;"	d
DB_SECONDARY_BAD	./include/db.h	1415;"	d
DB_SEQUENCE	./include/db.h	/^struct __db_sequence;	typedef struct __db_sequence DB_SEQUENCE;$/;"	t	typeref:struct:__db_sequence
DB_SEQUENCE_OLDVER	./include/db.h	1338;"	d
DB_SEQUENCE_STAT	./include/db.h	/^struct __db_seq_stat;	typedef struct __db_seq_stat DB_SEQUENCE_STAT;$/;"	t	typeref:struct:__db_seq_stat
DB_SEQUENCE_VERSION	./include/db.h	1337;"	d
DB_SEQ_DEC	./include/db.h	3040;"	d
DB_SEQ_INC	./include/db.h	3041;"	d
DB_SEQ_RANGE_SET	./include/db.h	3042;"	d
DB_SEQ_RECORD	./include/db.h	/^struct __db_seq_record; typedef struct __db_seq_record DB_SEQ_RECORD;$/;"	t	typeref:struct:__db_seq_record
DB_SEQ_WRAP	./include/db.h	3043;"	d
DB_SEQ_WRAPPED	./include/db.h	3044;"	d
DB_SET	./include/db.h	1369;"	d
DB_SET_LOCK_TIMEOUT	./include/db.h	3045;"	d
DB_SET_LTE	./include/db.h	1373;"	d
DB_SET_RANGE	./include/db.h	1370;"	d
DB_SET_RECNO	./include/db.h	1371;"	d
DB_SET_REG_TIMEOUT	./include/db.h	3046;"	d
DB_SET_TXN_LSNP	./include/db.h	584;"	d
DB_SET_TXN_NOW	./include/db.h	3047;"	d
DB_SET_TXN_TIMEOUT	./include/db.h	3048;"	d
DB_SHALLOW_DUP	./include/db.h	3049;"	d
DB_SITE	./include/db.h	/^struct __db_site;	typedef struct __db_site DB_SITE;$/;"	t	typeref:struct:__db_site
DB_SNAPSHOT	./include/db.h	3050;"	d
DB_STAT_ALL	./include/db.h	3051;"	d
DB_STAT_ALLOC	./include/db.h	3052;"	d
DB_STAT_CLEAR	./include/db.h	3053;"	d
DB_STAT_LOCK_CONF	./include/db.h	3054;"	d
DB_STAT_LOCK_LOCKERS	./include/db.h	3055;"	d
DB_STAT_LOCK_OBJECTS	./include/db.h	3056;"	d
DB_STAT_LOCK_PARAMS	./include/db.h	3057;"	d
DB_STAT_MEMP_HASH	./include/db.h	3058;"	d
DB_STAT_MEMP_NOERROR	./include/db.h	3059;"	d
DB_STAT_SUBSYSTEM	./include/db.h	3060;"	d
DB_STAT_SUMMARY	./include/db.h	3061;"	d
DB_STREAM	./include/db.h	/^struct __db_stream;	typedef struct __db_stream DB_STREAM;$/;"	t	typeref:struct:__db_stream
DB_STREAM_READ	./include/db.h	1864;"	d
DB_STREAM_SYNC_WRITE	./include/db.h	1866;"	d
DB_STREAM_WRITE	./include/db.h	1865;"	d
DB_ST_DUPOK	./include/db.h	3062;"	d
DB_ST_DUPSET	./include/db.h	3063;"	d
DB_ST_DUPSORT	./include/db.h	3064;"	d
DB_ST_IS_RECNO	./include/db.h	3065;"	d
DB_ST_OVFL_LEAF	./include/db.h	3066;"	d
DB_ST_RECNUM	./include/db.h	3067;"	d
DB_ST_RELEN	./include/db.h	3068;"	d
DB_ST_TOPLEVEL	./include/db.h	3069;"	d
DB_SURPRISE_KID	./include/db.h	1430;"	d
DB_SWAPBYTES	./include/db.h	1432;"	d
DB_SYSTEM_MEM	./include/db.h	3070;"	d
DB_THREAD	./include/db.h	3071;"	d
DB_THREADID_STRLEN	./include/db.h	282;"	d
DB_THREAD_INFO	./include/db.h	/^struct __db_thread_info;typedef struct __db_thread_info DB_THREAD_INFO;$/;"	t	typeref:struct:__db_thread_info
DB_TIMEOUT	./include/db.h	1416;"	d
DB_TIME_NOTGRANTED	./include/db.h	3072;"	d
DB_TRUNCATE	./include/db.h	3073;"	d
DB_TXN	./include/db.h	/^struct __db_txn;	typedef struct __db_txn DB_TXN;$/;"	t	typeref:struct:__db_txn
DB_TXNMGR	./include/db.h	/^struct __db_txnmgr;	typedef struct __db_txnmgr DB_TXNMGR;$/;"	t	typeref:struct:__db_txnmgr
DB_TXNVERSION	./include/db.h	801;"	d
DB_TXN_ABORT	./include/db.h	/^	DB_TXN_ABORT=0,			\/* Public. *\/$/;"	e	enum:__anon7
DB_TXN_ACTIVE	./include/db.h	/^struct __db_txn_active;	typedef struct __db_txn_active DB_TXN_ACTIVE;$/;"	t	typeref:struct:__db_txn_active
DB_TXN_APPLY	./include/db.h	/^	DB_TXN_APPLY=1,			\/* Public. *\/$/;"	e	enum:__anon7
DB_TXN_BACKWARD_ROLL	./include/db.h	/^	DB_TXN_BACKWARD_ROLL=3,		\/* Public. *\/$/;"	e	enum:__anon7
DB_TXN_BULK	./include/db.h	3074;"	d
DB_TXN_CKP	./include/db.h	1433;"	d
DB_TXN_FAMILY	./include/db.h	3075;"	d
DB_TXN_FORWARD_ROLL	./include/db.h	/^	DB_TXN_FORWARD_ROLL=4,		\/* Public. *\/$/;"	e	enum:__anon7
DB_TXN_LOG_VERIFY	./include/db.h	/^	DB_TXN_LOG_VERIFY=8		\/* Internal. *\/$/;"	e	enum:__anon7
DB_TXN_NOSYNC	./include/db.h	3076;"	d
DB_TXN_NOT_DURABLE	./include/db.h	3077;"	d
DB_TXN_NOWAIT	./include/db.h	3078;"	d
DB_TXN_OPENFILES	./include/db.h	/^	DB_TXN_OPENFILES=5,		\/* Internal. *\/$/;"	e	enum:__anon7
DB_TXN_POPENFILES	./include/db.h	/^	DB_TXN_POPENFILES=6,		\/* Internal. *\/$/;"	e	enum:__anon7
DB_TXN_PRINT	./include/db.h	/^	DB_TXN_PRINT=7,			\/* Public. *\/$/;"	e	enum:__anon7
DB_TXN_SNAPSHOT	./include/db.h	3079;"	d
DB_TXN_STAT	./include/db.h	/^struct __db_txn_stat;	typedef struct __db_txn_stat DB_TXN_STAT;$/;"	t	typeref:struct:__db_txn_stat
DB_TXN_SYNC	./include/db.h	3080;"	d
DB_TXN_TOKEN	./include/db.h	/^struct __db_txn_token;	typedef struct __db_txn_token DB_TXN_TOKEN;$/;"	t	typeref:struct:__db_txn_token
DB_TXN_TOKEN_SIZE	./include/db.h	1040;"	d
DB_TXN_WAIT	./include/db.h	3081;"	d
DB_TXN_WRITE_NOSYNC	./include/db.h	3082;"	d
DB_UNDO	./include/db.h	820;"	d
DB_UNKNOWN	./include/db.h	/^	DB_UNKNOWN=5			\/* Figure it out on open. *\/$/;"	e	enum:__anon13
DB_UNREF	./include/db.h	3083;"	d
DB_UPDATE_SECONDARY	./include/db.h	1372;"	d
DB_UPGRADE	./include/db.h	3084;"	d
DB_USE_ENVIRON	./include/db.h	3085;"	d
DB_USE_ENVIRON_ROOT	./include/db.h	3086;"	d
DB_VERB_BACKUP	./include/db.h	3087;"	d
DB_VERB_DEADLOCK	./include/db.h	3088;"	d
DB_VERB_FILEOPS	./include/db.h	3089;"	d
DB_VERB_FILEOPS_ALL	./include/db.h	3090;"	d
DB_VERB_MVCC	./include/db.h	3091;"	d
DB_VERB_RECOVERY	./include/db.h	3092;"	d
DB_VERB_REGISTER	./include/db.h	3093;"	d
DB_VERB_REPLICATION	./include/db.h	3094;"	d
DB_VERB_REPMGR_CONNFAIL	./include/db.h	3095;"	d
DB_VERB_REPMGR_MISC	./include/db.h	3096;"	d
DB_VERB_REP_ELECT	./include/db.h	3097;"	d
DB_VERB_REP_LEASE	./include/db.h	3098;"	d
DB_VERB_REP_MISC	./include/db.h	3099;"	d
DB_VERB_REP_MSGS	./include/db.h	3100;"	d
DB_VERB_REP_SYNC	./include/db.h	3101;"	d
DB_VERB_REP_SYSTEM	./include/db.h	3102;"	d
DB_VERB_REP_TEST	./include/db.h	3103;"	d
DB_VERB_WAITSFOR	./include/db.h	3104;"	d
DB_VERIFY	./include/db.h	3105;"	d
DB_VERIFY_BAD	./include/db.h	1417;"	d
DB_VERIFY_FATAL	./include/db.h	1434;"	d
DB_VERIFY_PARTITION	./include/db.h	3106;"	d
DB_VERSION_FAMILY	./include/db.h	45;"	d
DB_VERSION_FULL_STRING	./include/db.h	51;"	d
DB_VERSION_MAJOR	./include/db.h	47;"	d
DB_VERSION_MINOR	./include/db.h	48;"	d
DB_VERSION_MISMATCH	./include/db.h	1418;"	d
DB_VERSION_PATCH	./include/db.h	49;"	d
DB_VERSION_RELEASE	./include/db.h	46;"	d
DB_VERSION_STRING	./include/db.h	50;"	d
DB_WRITECURSOR	./include/db.h	3107;"	d
DB_WRITELOCK	./include/db.h	3108;"	d
DB_WRITEOPEN	./include/db.h	3109;"	d
DB_XA_CREATE	./include/db.h	3110;"	d
DB_YIELDCPU	./include/db.h	3111;"	d
DB_debug_FLAG	./include/db.h	508;"	d
DB_user_BEGIN	./include/db.h	507;"	d
ENTER	./include/db.h	/^	FIND, ENTER$/;"	e	enum:__anon25
ENTRY	./include/db.h	/^} ENTRY;$/;"	t	typeref:struct:entry
ENV	./include/db.h	/^struct __env;		typedef struct __env ENV;$/;"	t	typeref:struct:__env
FIND	./include/db.h	/^	FIND, ENTER$/;"	e	enum:__anon25
FNAME	./include/db.h	/^struct __fname;		typedef struct __fname FNAME;$/;"	t	typeref:struct:__fname
LOGREC_ARG	./include/db.h	/^	LOGREC_ARG,$/;"	e	enum:__anon4
LOGREC_DATA	./include/db.h	/^	LOGREC_DATA,$/;"	e	enum:__anon4
LOGREC_DB	./include/db.h	/^	LOGREC_DB,$/;"	e	enum:__anon4
LOGREC_DBOP	./include/db.h	/^	LOGREC_DBOP,$/;"	e	enum:__anon4
LOGREC_DBT	./include/db.h	/^	LOGREC_DBT,$/;"	e	enum:__anon4
LOGREC_Done	./include/db.h	/^	LOGREC_Done,$/;"	e	enum:__anon4
LOGREC_HDR	./include/db.h	/^	LOGREC_HDR,$/;"	e	enum:__anon4
LOGREC_LOCKS	./include/db.h	/^	LOGREC_LOCKS,$/;"	e	enum:__anon4
LOGREC_OP	./include/db.h	/^	LOGREC_OP,$/;"	e	enum:__anon4
LOGREC_PGDBT	./include/db.h	/^	LOGREC_PGDBT,$/;"	e	enum:__anon4
LOGREC_PGDDBT	./include/db.h	/^	LOGREC_PGDDBT,$/;"	e	enum:__anon4
LOGREC_PGLIST	./include/db.h	/^	LOGREC_PGLIST,$/;"	e	enum:__anon4
LOGREC_POINTER	./include/db.h	/^	LOGREC_POINTER,$/;"	e	enum:__anon4
LOGREC_TIME	./include/db.h	/^	LOGREC_TIME$/;"	e	enum:__anon4
LOG_DBT_SIZE	./include/db.h	617;"	d
MAX_N_OF_PROPOSERS	./include/paxos.h	80;"	d
MAX_RECORDS	./storage_mem.c	28;"	d	file:
MAX_SIZE_RECORD	./storage_mem.c	27;"	d	file:
MPOOLFILE	./include/db.h	/^struct __mpoolfile;	typedef struct __mpoolfile MPOOLFILE;$/;"	t	typeref:struct:__mpoolfile
MP_DUMMY	./include/db.h	722;"	d
MP_FILEID_SET	./include/db.h	716;"	d
MP_FLUSH	./include/db.h	717;"	d
MP_FOR_FLUSH	./include/db.h	718;"	d
MP_MULTIVERSION	./include/db.h	719;"	d
MP_OPEN_CALLED	./include/db.h	720;"	d
MP_READONLY	./include/db.h	721;"	d
PAXOS_LOG_DEBUG	./include/paxos.h	32;"	d
PAXOS_LOG_ERROR	./include/paxos.h	30;"	d
PAXOS_LOG_INFO	./include/paxos.h	31;"	d
PAXOS_LOG_QUIET	./include/paxos.h	29;"	d
PAXOS_MAX_VALUE_SIZE	./include/paxos.h	35;"	d
PAXOS_MSG_SIZE	./include/libpaxos_messages.h	47;"	d
PREPARE_ACK_SIZE	./include/libpaxos_messages.h	68;"	d
PREPARE_REQ_SIZE	./include/libpaxos_messages.h	57;"	d
TXN_ABORTED	./include/db.h	999;"	d
TXN_BULK	./include/db.h	968;"	d
TXN_CHILDCOMMIT	./include/db.h	950;"	d
TXN_COMMITTED	./include/db.h	1000;"	d
TXN_COMPENSATE	./include/db.h	951;"	d
TXN_DEADLOCK	./include/db.h	952;"	d
TXN_FAMILY	./include/db.h	953;"	d
TXN_IGNORE_LEASE	./include/db.h	954;"	d
TXN_INFAMILY	./include/db.h	955;"	d
TXN_LOCKTIMEOUT	./include/db.h	956;"	d
TXN_MALLOC	./include/db.h	957;"	d
TXN_NEED_ABORT	./include/db.h	1001;"	d
TXN_NOSYNC	./include/db.h	958;"	d
TXN_NOWAIT	./include/db.h	959;"	d
TXN_PREPARED	./include/db.h	1002;"	d
TXN_PRIVATE	./include/db.h	960;"	d
TXN_READONLY	./include/db.h	961;"	d
TXN_READ_COMMITTED	./include/db.h	962;"	d
TXN_READ_UNCOMMITTED	./include/db.h	963;"	d
TXN_RESTORED	./include/db.h	964;"	d
TXN_RUNNING	./include/db.h	1003;"	d
TXN_SNAPSHOT	./include/db.h	965;"	d
TXN_SYNC	./include/db.h	966;"	d
TXN_SYNC_FLAGS	./include/db.h	972;"	d
TXN_WRITE_NOSYNC	./include/db.h	967;"	d
TXN_XA_ACTIVE	./include/db.h	1006;"	d
TXN_XA_DEADLOCKED	./include/db.h	1007;"	d
TXN_XA_IDLE	./include/db.h	1008;"	d
TXN_XA_PREPARED	./include/db.h	1009;"	d
TXN_XA_ROLLEDBACK	./include/db.h	1010;"	d
TXN_XA_THREAD_ASSOCIATED	./include/db.h	945;"	d
TXN_XA_THREAD_NOTA	./include/db.h	944;"	d
TXN_XA_THREAD_SUSPENDED	./include/db.h	946;"	d
TXN_XA_THREAD_UNASSOCIATED	./include/db.h	947;"	d
_ACCEPTOR_H_	./include/acceptor.h	22;"	d
_CARRAY_H_	./include/carray.h	22;"	d
_DB_EXT_PROT_IN_	./include/db.h	3115;"	d
_DB_H_	./include/db.h	21;"	d
_LEARNER_H_	./include/learner.h	22;"	d
_LIBPAXOS_H_	./include/paxos.h	22;"	d
_LIBPAXOS_MESSAGES_H_	./include/libpaxos_messages.h	22;"	d
_PROPOSER_H_	./include/proposer.h	22;"	d
_QUORUM_H_	./include/quorum.h	22;"	d
_STORAGE_H_	./include/storage.h	22;"	d
__BIT_TYPES_DEFINED__	./include/db.h	67;"	d
__P	./include/db.h	39;"	d
__P	./include/db.h	40;"	d
__cq_aq	./include/db.h	/^	struct __cq_aq {$/;"	s	struct:__db
__cq_fq	./include/db.h	/^	struct __cq_fq {$/;"	s	struct:__db
__cq_jq	./include/db.h	/^	struct __cq_jq {$/;"	s	struct:__db
__db	./include/db.h	/^struct __db {$/;"	s
__db_bt_stat	./include/db.h	/^struct __db_bt_stat { \/* SHARED *\/$/;"	s
__db_channel	./include/db.h	/^struct __db_channel {$/;"	s
__db_compact	./include/db.h	/^struct __db_compact {$/;"	s
__db_dbt	./include/db.h	/^struct __db_dbt {$/;"	s
__db_distab	./include/db.h	/^struct __db_distab {$/;"	s
__db_env	./include/db.h	/^struct __db_env {$/;"	s
__db_h_stat	./include/db.h	/^struct __db_h_stat { \/* SHARED *\/$/;"	s
__db_heap_rid	./include/db.h	/^struct __db_heap_rid {$/;"	s
__db_heap_stat	./include/db.h	/^struct __db_heap_stat { \/* SHARED *\/$/;"	s
__db_ilock	./include/db.h	/^struct __db_ilock { \/* SHARED *\/$/;"	s
__db_lock_hstat	./include/db.h	/^struct __db_lock_hstat { \/* SHARED *\/$/;"	s
__db_lock_pstat	./include/db.h	/^struct __db_lock_pstat { \/* SHARED *\/$/;"	s
__db_lock_stat	./include/db.h	/^struct __db_lock_stat { \/* SHARED *\/$/;"	s
__db_lock_u	./include/db.h	/^struct __db_lock_u { \/* SHARED *\/$/;"	s
__db_lockreq	./include/db.h	/^struct __db_lockreq {$/;"	s
__db_log_cursor	./include/db.h	/^struct __db_log_cursor {$/;"	s
__db_log_stat	./include/db.h	/^struct __db_log_stat { \/* SHARED *\/$/;"	s
__db_logvrfy_config	./include/db.h	/^struct __db_logvrfy_config {$/;"	s
__db_lsn	./include/db.h	/^struct __db_lsn { \/* SHARED *\/$/;"	s
__db_mpool_fstat	./include/db.h	/^struct __db_mpool_fstat {$/;"	s
__db_mpool_stat	./include/db.h	/^struct __db_mpool_stat { \/* SHARED *\/$/;"	s
__db_mpoolfile	./include/db.h	/^struct __db_mpoolfile {$/;"	s
__db_mutex_stat	./include/db.h	/^struct __db_mutex_stat { \/* SHARED *\/$/;"	s
__db_preplist	./include/db.h	/^struct __db_preplist {$/;"	s
__db_qam_stat	./include/db.h	/^struct __db_qam_stat { \/* SHARED *\/$/;"	s
__db_rep_stat	./include/db.h	/^struct __db_rep_stat { \/* SHARED *\/$/;"	s
__db_repmgr_conn_err	./include/db.h	/^struct __db_repmgr_conn_err {$/;"	s
__db_repmgr_site	./include/db.h	/^struct __db_repmgr_site {$/;"	s
__db_repmgr_stat	./include/db.h	/^struct __db_repmgr_stat { \/* SHARED *\/$/;"	s
__db_seq_record	./include/db.h	/^struct __db_seq_record {$/;"	s
__db_seq_stat	./include/db.h	/^struct __db_seq_stat { \/* SHARED *\/$/;"	s
__db_sequence	./include/db.h	/^struct __db_sequence {$/;"	s
__db_site	./include/db.h	/^struct __db_site {$/;"	s
__db_stream	./include/db.h	/^struct __db_stream {$/;"	s
__db_txn	./include/db.h	/^struct __db_txn {$/;"	s
__db_txn_active	./include/db.h	/^struct __db_txn_active {$/;"	s
__db_txn_stat	./include/db.h	/^struct __db_txn_stat {$/;"	s
__db_txn_token	./include/db.h	/^struct __db_txn_token {$/;"	s
__dbc	./include/db.h	/^struct __dbc {$/;"	s
__femfs	./include/db.h	/^	struct __femfs {$/;"	s	struct:__db_txn
__key_range	./include/db.h	/^struct __key_range {$/;"	s
__kids	./include/db.h	/^	struct __kids {$/;"	s	struct:__db_txn
__log_rec_spec	./include/db.h	/^typedef const struct __log_rec_spec {$/;"	s
__my_cursors	./include/db.h	/^	struct __my_cursors {$/;"	s	struct:__db_txn
_carray_map	./carray.c	/^_carray_map(struct carray* a, int(*match_fn)(void*, void*), void* arg, int match) {    \/\/返回匹配\/不匹配的元素的队列$/;"	f	file:
abort	./include/db.h	/^	int	  (*abort) __P((DB_TXN *));$/;"	m	struct:__db_txn
accept_ack	./include/libpaxos_messages.h	/^} accept_ack;$/;"	t	typeref:struct:accept_ack_t
accept_ack_t	./include/libpaxos_messages.h	/^typedef struct accept_ack_t {        $/;"	s
accept_acks	./include/libpaxos_messages.h	/^	accept_acks=8,      \/\/Phase 2b, A->L$/;"	e	enum:pax_msg_code_e
accept_instances	./proposer.c	/^	struct carray* accept_instances; \/* Instance waiting for accept acks 接受accept回复的实例*\/$/;"	m	struct:proposer	typeref:struct:proposer::carray	file:
accept_req	./include/libpaxos_messages.h	/^} accept_req;$/;"	t	typeref:struct:accept_req_t
accept_req_t	./include/libpaxos_messages.h	/^typedef struct accept_req_t {$/;"	s
accept_reqs	./include/libpaxos_messages.h	/^	accept_reqs=4,      \/\/Phase 2a, P->A$/;"	e	enum:pax_msg_code_e
acceptor	./acceptor.c	/^struct acceptor$/;"	s	file:
acceptor_free	./acceptor.c	/^acceptor_free(struct acceptor* a)     \/\/释放数据库acceptor$/;"	f
acceptor_id	./include/libpaxos_messages.h	/^	int acceptor_id;$/;"	m	struct:accept_ack_t
acceptor_id	./include/libpaxos_messages.h	/^	int acceptor_id;$/;"	m	struct:prepare_ack_t
acceptor_id	./storage_bdb.c	/^	int acceptor_id;$/;"	m	struct:storage	file:
acceptor_id	./storage_mem.c	/^	int acceptor_id;$/;"	m	struct:storage	file:
acceptor_ids	./include/quorum.h	/^	int* acceptor_ids;$/;"	m	struct:quorum
acceptor_new	./acceptor.c	/^acceptor_new(int id)          \/\/用一个数据库存储$/;"	f
acceptor_receive_accept	./acceptor.c	/^acceptor_receive_accept(struct acceptor* a, accept_req* req)       \/\/取出accept请求$/;"	f
acceptor_receive_prepare	./acceptor.c	/^acceptor_receive_prepare(struct acceptor* a, prepare_req* req)$/;"	f
acceptor_receive_repeat	./acceptor.c	/^acceptor_receive_repeat(struct acceptor* a, iid_t iid)$/;"	f
acceptor_record	./include/libpaxos_messages.h	/^typedef accept_ack acceptor_record;$/;"	t
acceptors	./include/quorum.h	/^	int acceptors;$/;"	m	struct:quorum
acceptors	./learner.c	/^	int acceptors;$/;"	m	struct:learner	file:
acceptors	./proposer.c	/^	int acceptors;$/;"	m	struct:proposer	file:
acks	./learner.c	/^	accept_ack** acks;$/;"	m	struct:instance	file:
active_queue	./include/db.h	/^	} active_queue;$/;"	m	struct:__db	typeref:struct:__db::__cq_aq
add_data_dir	./include/db.h	/^	int  (*add_data_dir) __P((DB_ENV *, const char *));$/;"	m	struct:__db_env
addr	./include/db.h	/^	void	       *addr;		\/* Address of mmap'd region. *\/$/;"	m	struct:__db_mpoolfile
adj_fileid	./include/db.h	/^	u_int32_t adj_fileid;		\/* File's unique ID for curs. adj. *\/$/;"	m	struct:__db
ai	./proposer.c	/^	int pi, ai;$/;"	m	struct:timeout_iterator	file:
alive_ping	./include/libpaxos_messages.h	/^	alive_ping=65       \/\/Proposers to oracle$/;"	e	enum:pax_msg_code_e
alt_close	./include/db.h	/^	int  (*alt_close) __P((DB *, u_int32_t));$/;"	m	struct:__db
am_bulk	./include/db.h	/^	int (*am_bulk) __P((DBC *, DBT *, u_int32_t));$/;"	m	struct:__dbc
am_close	./include/db.h	/^	int (*am_close) __P((DBC *, db_pgno_t, int *));$/;"	m	struct:__dbc
am_del	./include/db.h	/^	int (*am_del) __P((DBC *, u_int32_t));$/;"	m	struct:__dbc
am_destroy	./include/db.h	/^	int (*am_destroy) __P((DBC *));$/;"	m	struct:__dbc
am_get	./include/db.h	/^	int (*am_get) __P((DBC *, DBT *, DBT *, u_int32_t, db_pgno_t *));$/;"	m	struct:__dbc
am_ok	./include/db.h	/^	u_int32_t	am_ok;		\/* Legal AM choices. *\/$/;"	m	struct:__db
am_put	./include/db.h	/^	int (*am_put) __P((DBC *, DBT *, DBT *, u_int32_t, db_pgno_t *));$/;"	m	struct:__dbc
am_writelock	./include/db.h	/^	int (*am_writelock) __P((DBC *));$/;"	m	struct:__dbc
api1_internal	./include/db.h	/^	void	*api1_internal;		\/* C++, Perl API private *\/$/;"	m	struct:__db_env
api2_internal	./include/db.h	/^	void	*api2_internal;		\/* Java API private *\/$/;"	m	struct:__db_env
api_internal	./include/db.h	/^	void		*api_internal;$/;"	m	struct:__db_sequence
api_internal	./include/db.h	/^	void	*api_internal;		\/* C++ API private. *\/$/;"	m	struct:__db_txn
api_internal	./include/db.h	/^	void	*api_internal;$/;"	m	struct:__db
app_data	./include/db.h	/^	void *app_data;$/;"	m	struct:__db_dbt
app_dispatch	./include/db.h	/^	int   (*app_dispatch) __P((DB_ENV *, DBT *, DB_LSN *, db_recops));$/;"	m	struct:__db_env
app_private	./include/db.h	/^	void	*app_private;		\/* Application-private handle *\/$/;"	m	struct:__db_env
app_private	./include/db.h	/^	void	*app_private;		\/* Application-private handle. *\/$/;"	m	struct:__db
apply_accept	./acceptor.c	/^apply_accept(struct storage* s, accept_req* ar, acceptor_record* rec)$/;"	f	file:
apply_prepare	./acceptor.c	/^apply_prepare(struct storage* s, prepare_req* pr, acceptor_record* rec)          \/\/处理prepare事务$/;"	f	file:
array	./carray.c	/^	void** array;$/;"	m	struct:carray	file:
associate	./include/db.h	/^	int  (*associate) __P((DB *, DB_TXN *, DB *,$/;"	m	struct:__db
associate_foreign	./include/db.h	/^	int  (*associate_foreign) __P((DB *, DB *,$/;"	m	struct:__db
associate_locker	./include/db.h	/^	DB_LOCKER *associate_locker;	\/* Locker for DB->associate call. *\/$/;"	m	struct:__db
backup	./include/db.h	/^	int  (*backup)	__P((DB_ENV *, const char *, u_int32_t));$/;"	m	struct:__db_env
ballot	./include/libpaxos_messages.h	/^	ballot_t ballot;$/;"	m	struct:accept_ack_t
ballot	./include/libpaxos_messages.h	/^	ballot_t ballot;$/;"	m	struct:accept_req_t
ballot	./include/libpaxos_messages.h	/^	ballot_t ballot;$/;"	m	struct:prepare_ack_t
ballot	./include/libpaxos_messages.h	/^	ballot_t ballot;$/;"	m	struct:prepare_req_t
ballot	./proposer.c	/^	ballot_t ballot;$/;"	m	struct:instance	file:
ballot_t	./include/paxos.h	/^typedef uint32_t ballot_t;$/;"	t
bdb_cachesize	./include/paxos.h	/^	int bdb_cachesize;$/;"	m	struct:paxos_config
bdb_db_filename	./include/paxos.h	/^	char* bdb_db_filename;$/;"	m	struct:paxos_config
bdb_env_path	./include/paxos.h	/^	char* bdb_env_path;$/;"	m	struct:paxos_config
bdb_init_db	./storage_bdb.c	/^bdb_init_db(struct storage* s, char* db_path)$/;"	f	file:
bdb_init_tx_handle	./storage_bdb.c	/^bdb_init_tx_handle(struct storage* s, char* db_env_path)     \/\/初始化事物句柄$/;"	f	file:
bdb_sync	./include/paxos.h	/^	int bdb_sync;$/;"	m	struct:paxos_config
bdb_trash_files	./include/paxos.h	/^	int bdb_trash_files;$/;"	m	struct:paxos_config
blob_file_id	./include/db.h	/^	uintmax_t	blob_file_id;	\/* Id of the file blob directory. *\/$/;"	m	struct:__db
blob_id	./include/db.h	/^	uintmax_t	blob_id;$/;"	m	struct:__db_stream
blob_meta_db	./include/db.h	/^	DB		*blob_meta_db;	\/* Databases holding blob metadata. *\/$/;"	m	struct:__db
blob_sdb_id	./include/db.h	/^	uintmax_t	blob_sdb_id;	\/* Id of the subdb blob directory. *\/$/;"	m	struct:__db
blob_seq	./include/db.h	/^	DB_SEQUENCE	*blob_seq;	\/* Sequence of blob ids. *\/$/;"	m	struct:__db
blob_sub_dir	./include/db.h	/^	char		*blob_sub_dir;	\/* Subdirectory for blob files *\/$/;"	m	struct:__db
blob_threshold	./include/db.h	/^	u_int32_t	blob_threshold;	\/* Blob threshold record size *\/$/;"	m	struct:__db_env
blob_threshold	./include/db.h	/^	u_int32_t blob_threshold;	\/* Blob threshold record size. *\/$/;"	m	struct:__db
bp	./include/db.h	/^	u_int8_t *bp;			\/* Allocated read buffer. *\/$/;"	m	struct:__db_log_cursor
bp_lsn	./include/db.h	/^	DB_LSN	  bp_lsn;		\/* Read buffer first byte LSN. *\/$/;"	m	struct:__db_log_cursor
bp_maxrec	./include/db.h	/^	u_int32_t bp_maxrec;		\/* Max record length in the log file. *\/$/;"	m	struct:__db_log_cursor
bp_rlen	./include/db.h	/^	u_int32_t bp_rlen;		\/* Read buffer valid data length. *\/$/;"	m	struct:__db_log_cursor
bp_size	./include/db.h	/^	u_int32_t bp_size;		\/* Read buffer length in bytes. *\/$/;"	m	struct:__db_log_cursor
bt_dup_pg	./include/db.h	/^	u_int32_t bt_dup_pg;		\/* Duplicate pages. *\/$/;"	m	struct:__db_bt_stat
bt_dup_pgfree	./include/db.h	/^	uintmax_t bt_dup_pgfree;	\/* Bytes free in duplicate pages. *\/$/;"	m	struct:__db_bt_stat
bt_empty_pg	./include/db.h	/^	u_int32_t bt_empty_pg;		\/* Empty pages. *\/$/;"	m	struct:__db_bt_stat
bt_free	./include/db.h	/^	u_int32_t bt_free;		\/* Pages on the free list. *\/$/;"	m	struct:__db_bt_stat
bt_int_pg	./include/db.h	/^	u_int32_t bt_int_pg;		\/* Internal pages. *\/$/;"	m	struct:__db_bt_stat
bt_int_pgfree	./include/db.h	/^	uintmax_t bt_int_pgfree;	\/* Bytes free in internal pages. *\/$/;"	m	struct:__db_bt_stat
bt_internal	./include/db.h	/^	void	*bt_internal;		\/* Btree\/Recno access method. *\/$/;"	m	struct:__db
bt_leaf_pg	./include/db.h	/^	u_int32_t bt_leaf_pg;		\/* Leaf pages. *\/$/;"	m	struct:__db_bt_stat
bt_leaf_pgfree	./include/db.h	/^	uintmax_t bt_leaf_pgfree;	\/* Bytes free in leaf pages. *\/$/;"	m	struct:__db_bt_stat
bt_levels	./include/db.h	/^	u_int32_t bt_levels;		\/* Tree levels. *\/$/;"	m	struct:__db_bt_stat
bt_magic	./include/db.h	/^	u_int32_t bt_magic;		\/* Magic number. *\/$/;"	m	struct:__db_bt_stat
bt_metaflags	./include/db.h	/^	u_int32_t bt_metaflags;		\/* Metadata flags. *\/$/;"	m	struct:__db_bt_stat
bt_minkey	./include/db.h	/^	u_int32_t bt_minkey;		\/* Minkey value. *\/$/;"	m	struct:__db_bt_stat
bt_nblobs	./include/db.h	/^	u_int32_t bt_nblobs;		\/* Number of blobs. *\/$/;"	m	struct:__db_bt_stat
bt_ndata	./include/db.h	/^	u_int32_t bt_ndata;		\/* Number of data items. *\/$/;"	m	struct:__db_bt_stat
bt_nkeys	./include/db.h	/^	u_int32_t bt_nkeys;		\/* Number of unique keys. *\/$/;"	m	struct:__db_bt_stat
bt_over_pg	./include/db.h	/^	u_int32_t bt_over_pg;		\/* Overflow pages. *\/$/;"	m	struct:__db_bt_stat
bt_over_pgfree	./include/db.h	/^	uintmax_t bt_over_pgfree;	\/* Bytes free in overflow pages. *\/$/;"	m	struct:__db_bt_stat
bt_pagecnt	./include/db.h	/^	u_int32_t bt_pagecnt;		\/* Page count. *\/$/;"	m	struct:__db_bt_stat
bt_pagesize	./include/db.h	/^	u_int32_t bt_pagesize;		\/* Page size. *\/$/;"	m	struct:__db_bt_stat
bt_re_len	./include/db.h	/^	u_int32_t bt_re_len;		\/* Fixed-length record length. *\/$/;"	m	struct:__db_bt_stat
bt_re_pad	./include/db.h	/^	u_int32_t bt_re_pad;		\/* Fixed-length record pad. *\/$/;"	m	struct:__db_bt_stat
bt_version	./include/db.h	/^	u_int32_t bt_version;		\/* Version number. *\/$/;"	m	struct:__db_bt_stat
buf	./include/db.h	/^	u_int8_t buf[DB_TXN_TOKEN_SIZE];$/;"	m	struct:__db_txn_token
bytes	./include/db.h	/^	u_int32_t	gbytes, bytes;	\/* Maximum file size. *\/$/;"	m	struct:__db_mpoolfile
c_close	./include/db.h	/^	int (*c_close) __P((DBC *));$/;"	m	struct:__dbc
c_count	./include/db.h	/^	int (*c_count) __P((DBC *, db_recno_t *, u_int32_t));$/;"	m	struct:__dbc
c_del	./include/db.h	/^	int (*c_del) __P((DBC *, u_int32_t));$/;"	m	struct:__dbc
c_dup	./include/db.h	/^	int (*c_dup) __P((DBC *, DBC **, u_int32_t));$/;"	m	struct:__dbc
c_get	./include/db.h	/^	int (*c_get) __P((DBC *, DBT *, DBT *, u_int32_t));$/;"	m	struct:__dbc
c_pget	./include/db.h	/^	int (*c_pget) __P((DBC *, DBT *, DBT *, DBT *, u_int32_t));$/;"	m	struct:__dbc
c_put	./include/db.h	/^	int (*c_put) __P((DBC *, DBT *, DBT *, u_int32_t));$/;"	m	struct:__dbc
cachesize	./include/db.h	/^	u_int32_t cachesize;$/;"	m	struct:__db_logvrfy_config
carray	./carray.c	/^struct carray {$/;"	s	file:
carray_at	./carray.c	/^void* carray_at(struct carray* a, int i) {               \/\/索引为i的元素$/;"	f
carray_collect	./carray.c	/^struct carray* carray_collect(struct carray* a, int(*match_fn)(void*, void*), void* arg) {    \/\/返回匹配的元素的队列$/;"	f
carray_count	./carray.c	/^int carray_count(struct carray* a) {$/;"	f
carray_count_match	./carray.c	/^int carray_count_match(struct carray* a, int(*match_fn)(void*, void*), void* arg) {      \/\/返回匹配元素个数$/;"	f
carray_empty	./carray.c	/^int carray_empty(struct carray* a) {$/;"	f
carray_first_match	./carray.c	/^void* carray_first_match(struct carray* a, int(*match_fn)(void*, void*), void* arg) {$/;"	f
carray_free	./carray.c	/^void carray_free(struct carray* a) {$/;"	f
carray_front	./carray.c	/^void* carray_front(struct carray* a) {         \/\/返回第一个元素$/;"	f
carray_full	./carray.c	/^static int carray_full(struct carray* a) {$/;"	f	file:
carray_grow	./carray.c	/^static void carray_grow(struct carray* a) {$/;"	f	file:
carray_new	./carray.c	/^struct carray* carray_new(int size) {$/;"	f
carray_pop_front	./carray.c	/^void* carray_pop_front(struct carray* a) {    \/\/返回并移除头部元素$/;"	f
carray_push_back	./carray.c	/^int carray_push_back(struct carray* a, void* p) {         \/\/尾部追加$/;"	f
carray_push_front	./carray.c	/^int carray_push_front(struct carray* a, void* p) {   \/\/头部插入$/;"	f
carray_reject	./carray.c	/^struct carray* carray_reject(struct carray* a, int(*match_fn)(void*, void*), void* arg) {    \/\/返回不匹配的元素队列$/;"	f
carray_size	./carray.c	/^int carray_size(struct carray* a) {$/;"	f
cdsgroup_begin	./include/db.h	/^	int  (*cdsgroup_begin) __P((DB_ENV *, DB_TXN **));$/;"	m	struct:__db_env
channel	./include/db.h	/^	CHANNEL *channel;	\/* Pointer to internal state details. *\/$/;"	m	struct:__db_channel
clear_len	./include/db.h	/^	u_int32_t	clear_len;	\/* Cleared length on created pages. *\/$/;"	m	struct:__db_mpoolfile
close	./include/db.h	/^	int		(*close) __P((DB_SEQUENCE *, u_int32_t));$/;"	m	struct:__db_sequence
close	./include/db.h	/^	int  (*close) __P((DB *, u_int32_t));$/;"	m	struct:__db
close	./include/db.h	/^	int  (*close) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
close	./include/db.h	/^	int  (*close) __P((DB_STREAM *, u_int32_t));$/;"	m	struct:__db_stream
close	./include/db.h	/^	int (*close) __P((DBC *));$/;"	m	struct:__dbc
close	./include/db.h	/^	int (*close) __P((DB_CHANNEL *, u_int32_t));$/;"	m	struct:__db_channel
close	./include/db.h	/^	int (*close) __P((DB_LOGC *, u_int32_t));$/;"	m	struct:__db_log_cursor
close	./include/db.h	/^	int (*close) __P((DB_MPOOLFILE *, u_int32_t));$/;"	m	struct:__db_mpoolfile
close	./include/db.h	/^	int (*close) __P((DB_SITE *));$/;"	m	struct:__db_site
closed	./proposer.c	/^	int closed;$/;"	m	struct:instance	file:
cmp	./include/db.h	/^	int (*cmp) __P((DBC *, DBC *, int *, u_int32_t));$/;"	m	struct:__dbc
commit	./include/db.h	/^	int	  (*commit) __P((DB_TXN *, u_int32_t));$/;"	m	struct:__db_txn
compact	./include/db.h	/^	int  (*compact) __P((DB *,$/;"	m	struct:__db
compact_deadlock	./include/db.h	/^	u_int32_t	compact_deadlock;	\/* Number of deadlocks. *\/$/;"	m	struct:__db_compact
compact_empty_buckets	./include/db.h	/^	u_int32_t	compact_empty_buckets;	\/* Empty hash buckets found. *\/$/;"	m	struct:__db_compact
compact_fillpercent	./include/db.h	/^	u_int32_t	compact_fillpercent;	\/* Desired fillfactor: 1-100 *\/$/;"	m	struct:__db_compact
compact_levels	./include/db.h	/^	u_int32_t	compact_levels;		\/* Number of levels removed. *\/$/;"	m	struct:__db_compact
compact_pages	./include/db.h	/^	u_int32_t	compact_pages;		\/* Max pages to process. *\/$/;"	m	struct:__db_compact
compact_pages_examine	./include/db.h	/^	u_int32_t	compact_pages_examine;	\/* Number of pages examine. *\/$/;"	m	struct:__db_compact
compact_pages_free	./include/db.h	/^	u_int32_t	compact_pages_free;	\/* Number of pages freed. *\/$/;"	m	struct:__db_compact
compact_pages_truncated	./include/db.h	/^	db_pgno_t	compact_pages_truncated; \/* Pages truncated to OS. *\/$/;"	m	struct:__db_compact
compact_timeout	./include/db.h	/^	db_timeout_t	compact_timeout;	\/* Lock timeout. *\/$/;"	m	struct:__db_compact
compact_truncate	./include/db.h	/^	db_pgno_t	compact_truncate;	\/* Exchange pages above here. *\/$/;"	m	struct:__db_compact
config_flags	./include/db.h	/^	u_int32_t	config_flags;	\/* Flags to DB_MPOOLFILE->set_flags. *\/$/;"	m	struct:__db_mpoolfile
continue_after_fail	./include/db.h	/^	int continue_after_fail, verbose;$/;"	m	struct:__db_logvrfy_config
count	./carray.c	/^	int count;$/;"	m	struct:carray	file:
count	./include/db.h	/^	int (*count) __P((DBC *, db_recno_t *, u_int32_t));$/;"	m	struct:__dbc
count	./include/quorum.h	/^	int count;$/;"	m	struct:quorum
created_at	./proposer.c	/^	struct timeval created_at;$/;"	m	struct:instance	typeref:struct:instance::timeval	file:
cur_locker	./include/db.h	/^	DB_LOCKER *cur_locker;		\/* Current handle lock holder. *\/$/;"	m	struct:__db
cur_txn	./include/db.h	/^	DB_TXN *cur_txn;		\/* Opening transaction. *\/$/;"	m	struct:__db
current_iid	./learner.c	/^	iid_t current_iid;$/;"	m	struct:learner	file:
cursor	./include/db.h	/^	int  (*cursor) __P((DB *, DB_TXN *, DBC **, u_int32_t));$/;"	m	struct:__db
cursors	./include/db.h	/^	u_int32_t	cursors;	\/* Number of cursors open for txn *\/$/;"	m	struct:__db_txn
data	./include/db.h	/^	char *data;$/;"	m	struct:entry
data	./include/db.h	/^	void	 *data;			\/* Key\/data *\/$/;"	m	struct:__db_dbt
data	./include/libpaxos_messages.h	/^	char data[0];$/;"	m	struct:paxos_msg_t
data_cnt	./include/db.h	/^	int	 data_cnt;		\/* Database data file slots *\/$/;"	m	struct:__db_env
data_next	./include/db.h	/^	int	 data_next;		\/* Next database data file slot *\/$/;"	m	struct:__db_env
data_size	./include/libpaxos_messages.h	/^	size_t data_size; \/\/Size of 'data' in bytes$/;"	m	struct:paxos_msg_t
datum	./include/db.h	/^} datum;$/;"	t	typeref:struct:__anon23
datum	./include/db.h	/^} datum;$/;"	t	typeref:struct:__anon24
db	./storage_bdb.c	/^	DB* db;$/;"	m	struct:storage	file:
db_am_remove	./include/db.h	/^	int  (*db_am_remove) __P((DB *, DB_THREAD_INFO *,$/;"	m	struct:__db
db_am_rename	./include/db.h	/^	int  (*db_am_rename) __P((DB *, DB_THREAD_INFO *,$/;"	m	struct:__db
db_append_recno	./include/db.h	/^	int (*db_append_recno) __P((DB *, DBT *, db_recno_t));$/;"	m	struct:__db
db_blob_dir	./include/db.h	/^	char	*db_blob_dir;		\/* Blob file directory *\/$/;"	m	struct:__db_env
db_create_dir	./include/db.h	/^	char    *db_create_dir;		\/* Create directory for data files *\/$/;"	m	struct:__db_env
db_data_dir	./include/db.h	/^	char   **db_data_dir;		\/* Database data file directories *\/$/;"	m	struct:__db_env
db_errcall	./include/db.h	/^	void (*db_errcall) __P((const DB_ENV *, const char *, const char *));$/;"	m	struct:__db_env
db_errfile	./include/db.h	/^	FILE		*db_errfile;	\/* Error message file stream *\/$/;"	m	struct:__db_env
db_errpfx	./include/db.h	/^	const char	*db_errpfx;	\/* Error message prefix *\/$/;"	m	struct:__db_env
db_event_func	./include/db.h	/^	void  (*db_event_func) __P((DB_ENV *, u_int32_t, void *));$/;"	m	struct:__db_env
db_feedback	./include/db.h	/^	void  (*db_feedback) __P((DB_ENV *, int, int));$/;"	m	struct:__db_env
db_feedback	./include/db.h	/^	void (*db_feedback) __P((DB *, int, int));$/;"	m	struct:__db
db_free	./include/db.h	/^	void  (*db_free) __P((void *));$/;"	m	struct:__db_env
db_indx_t	./include/db.h	/^typedef	u_int16_t	db_indx_t;	\/* Page offset type. *\/$/;"	t
db_lockmode_t	./include/db.h	/^} db_lockmode_t;$/;"	t	typeref:enum:__anon1
db_lockop_t	./include/db.h	/^} db_lockop_t;$/;"	t	typeref:enum:__anon2
db_log_dir	./include/db.h	/^	char	*db_log_dir;		\/* Database log file directory *\/$/;"	m	struct:__db_env
db_malloc	./include/db.h	/^	void *(*db_malloc) __P((size_t));$/;"	m	struct:__db_env
db_md_dir	./include/db.h	/^	char	*db_md_dir;		\/* Persistent metadata directory *\/$/;"	m	struct:__db_env
db_msgcall	./include/db.h	/^	void (*db_msgcall) __P((const DB_ENV *, const char *));$/;"	m	struct:__db_env
db_msgfile	./include/db.h	/^	FILE		*db_msgfile;	\/* Other message file stream *\/$/;"	m	struct:__db_env
db_mutex_t	./include/db.h	/^typedef db_size_t	db_mutex_t;$/;"	t
db_mutex_t	./include/db.h	/^typedef uintptr_t	db_mutex_t;$/;"	t
db_off_t	./include/db.h	/^typedef int db_off_t;$/;"	t
db_paniccall	./include/db.h	/^	void  (*db_paniccall) __P((DB_ENV *, int));$/;"	m	struct:__db_env
db_pgno_t	./include/db.h	/^typedef	u_int32_t	db_pgno_t;	\/* Page number type. *\/$/;"	t
db_realloc	./include/db.h	/^	void *(*db_realloc) __P((void *, size_t));$/;"	m	struct:__db_env
db_recno_t	./include/db.h	/^typedef	u_int32_t	db_recno_t;	\/* Record number type. *\/$/;"	t
db_recops	./include/db.h	/^} db_recops;$/;"	t	typeref:enum:__anon7
db_seq_t	./include/db.h	/^typedef long long db_seq_t;$/;"	t
db_size_t	./include/db.h	/^typedef size_t db_size_t;$/;"	t
db_size_t	./include/db.h	/^typedef u_int32_t db_size_t;$/;"	t
db_ssize_t	./include/db.h	/^typedef int32_t db_ssize_t;$/;"	t
db_ssize_t	./include/db.h	/^typedef ssize_t db_ssize_t;$/;"	t
db_status_t	./include/db.h	/^}db_status_t;$/;"	t	typeref:enum:__anon3
db_stream	./include/db.h	/^	int (*db_stream) __P((DBC *, DB_STREAM **, u_int32_t));$/;"	m	struct:__dbc
db_threadid_t	./include/db.h	/^typedef pthread_t db_threadid_t;$/;"	t
db_timeout_t	./include/db.h	/^typedef u_int32_t	db_timeout_t;	\/* Type of a timeout. *\/$/;"	t
db_tmp_dir	./include/db.h	/^	char	*db_tmp_dir;		\/* Database tmp file directory *\/$/;"	m	struct:__db_env
dbbackup	./include/db.h	/^	int  (*dbbackup) __P((DB_ENV *, const char *, const char *, u_int32_t));$/;"	m	struct:__db_env
dbc	./include/db.h	/^	DBC		*dbc;	\/* Cursor pointing to the db blob record. *\/$/;"	m	struct:__db_stream
dbenv	./include/db.h	/^	DB_ENV	*dbenv;			\/* Backing public environment. *\/$/;"	m	struct:__db
dbenv	./include/db.h	/^	DB_ENV *dbenv;			\/* Backing environment *\/$/;"	m	struct:__dbc
dbfile	./include/db.h	/^	const char *dbfile, *dbname;$/;"	m	struct:__db_logvrfy_config
dblistlinks	./include/db.h	/^	} dblistlinks;$/;"	m	struct:__db	typeref:struct:__db::__anon14
dbm_clearerr	./include/db.h	2826;"	d
dbm_close	./include/db.h	2827;"	d
dbm_delete	./include/db.h	2828;"	d
dbm_dirfno	./include/db.h	2829;"	d
dbm_error	./include/db.h	2830;"	d
dbm_fetch	./include/db.h	2831;"	d
dbm_firstkey	./include/db.h	2832;"	d
dbm_nextkey	./include/db.h	2833;"	d
dbm_open	./include/db.h	2834;"	d
dbm_pagfno	./include/db.h	2835;"	d
dbm_rdonly	./include/db.h	2836;"	d
dbm_store	./include/db.h	2837;"	d
dbmclose	./include/db.h	2848;"	d
dbminit	./include/db.h	2847;"	d
dbname	./include/db.h	/^	const char *dbfile, *dbname;$/;"	m	struct:__db_logvrfy_config
dbp	./include/db.h	/^	DB *dbp;			\/* Backing database *\/$/;"	m	struct:__dbc
dbremove	./include/db.h	/^	int  (*dbremove) __P((DB_ENV *,$/;"	m	struct:__db_env
dbrename	./include/db.h	/^	int  (*dbrename) __P((DB_ENV *,$/;"	m	struct:__db_env
dbt	./include/db.h	/^	DBT	  dbt;			\/* Return DBT. *\/$/;"	m	struct:__db_log_cursor
dbtype	./include/db.h	/^	DBTYPE	  dbtype;		\/* Cursor type. *\/$/;"	m	struct:__dbc
del	./include/db.h	/^	int  (*del) __P((DB *, DB_TXN *, DBT *, u_int32_t));$/;"	m	struct:__db
del	./include/db.h	/^	int (*del) __P((DBC *, u_int32_t));$/;"	m	struct:__dbc
delete	./include/db.h	2850;"	d
dirname	./include/db.h	/^	const char *dirname;		\/* Directory of DB file. *\/$/;"	m	struct:__db
discard	./include/db.h	/^	int	  (*discard) __P((DB_TXN *, u_int32_t));$/;"	m	struct:__db_txn
dlen	./include/db.h	/^	u_int32_t dlen;			\/* RO: get\/put record length. *\/$/;"	m	struct:__db_dbt
dname	./include/db.h	/^	char *fname, *dname;		\/* File\/database passed to DB->open. *\/$/;"	m	struct:__db
doff	./include/db.h	/^	u_int32_t doff;			\/* RO: get\/put record offset. *\/$/;"	m	struct:__db_dbt
dptr	./include/db.h	/^	char *dptr;$/;"	m	struct:__anon23
dptr	./include/db.h	/^	char *dptr;$/;"	m	struct:__anon24
dsize	./include/db.h	/^	int dsize;$/;"	m	struct:__anon24
dsize	./include/db.h	/^	size_t dsize;$/;"	m	struct:__anon23
dump	./include/db.h	/^	int  (*dump) __P((DB *, const char *,$/;"	m	struct:__db
dup	./include/db.h	/^	int (*dup) __P((DBC *, DBC **, u_int32_t));$/;"	m	struct:__dbc
dup_compare	./include/db.h	/^	int (*dup_compare) __P((DB *, const DBT *, const DBT *, size_t *));$/;"	m	struct:__db
eid	./include/db.h	/^	int		eid;		\/* Replication Environment ID. *\/$/;"	m	struct:__db_repmgr_conn_err
eid	./include/db.h	/^	int eid;		\/* Env. ID passed in constructor. *\/$/;"	m	struct:__db_channel
eid	./include/db.h	/^	int eid;$/;"	m	struct:__db_repmgr_site
eid	./include/db.h	/^	int eid;$/;"	m	struct:__db_site
end_lsn	./include/db.h	/^	DB_LSN start_lsn, end_lsn;$/;"	m	struct:__db_logvrfy_config
end_time	./include/db.h	/^	time_t start_time, end_time;$/;"	m	struct:__db_logvrfy_config
entry	./include/db.h	/^typedef struct entry {$/;"	s
env	./include/db.h	/^	ENV	       *env;		\/* Environment *\/$/;"	m	struct:__db_mpoolfile
env	./include/db.h	/^	ENV	 *env;			\/* Environment *\/$/;"	m	struct:__db_log_cursor
env	./include/db.h	/^	ENV	*env;			\/* Backing private environment. *\/$/;"	m	struct:__db
env	./include/db.h	/^	ENV *env;			\/* Backing environment *\/$/;"	m	struct:__dbc
env	./include/db.h	/^	ENV *env;			\/* Linked ENV structure *\/$/;"	m	struct:__db_env
env	./include/db.h	/^	ENV *env;$/;"	m	struct:__db_site
env	./storage_bdb.c	/^	DB_ENV* env;$/;"	m	struct:storage	file:
envreg_timeout	./include/db.h	/^        db_timeout_t	envreg_timeout; \/* DB_REGISTER wait timeout *\/$/;"	m	struct:__db_env
equal	./include/db.h	/^	double equal;$/;"	m	struct:__key_range
err	./include/db.h	/^	void (*err) __P((DB *, int, const char *, ...));$/;"	m	struct:__db
err	./include/db.h	/^	void (*err) __P((const DB_ENV *, int, const char *, ...));$/;"	m	struct:__db_env
error	./include/db.h	/^	int		error;		\/* System networking error code. *\/$/;"	m	struct:__db_repmgr_conn_err
errx	./include/db.h	/^	void (*errx) __P((DB *, const char *, ...));$/;"	m	struct:__db
errx	./include/db.h	/^	void (*errx) __P((const DB_ENV *, const char *, ...));$/;"	m	struct:__db_env
events	./include/db.h	/^	} events;			\/* Links deferred events. *\/$/;"	m	struct:__db_txn	typeref:struct:__db_txn::__anon10
exists	./include/db.h	/^	int  (*exists) __P((DB *, DB_TXN *, DBT *, u_int32_t));$/;"	m	struct:__db
ext_dispatch	./include/db.h	/^	int   (**ext_dispatch) __P((DB_ENV *, DBT *, DB_LSN *, db_recops));$/;"	m	struct:__db_distab
ext_size	./include/db.h	/^	size_t	ext_size;$/;"	m	struct:__db_distab
f_primaries	./include/db.h	/^	} f_primaries;$/;"	m	struct:__db	typeref:struct:__db::__anon17
failchk	./include/db.h	/^	int  (*failchk) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
fd	./include/db.h	/^	int  (*fd) __P((DB *, int *));$/;"	m	struct:__db
felink	./include/db.h	/^	} felink;$/;"	m	struct:__db	typeref:struct:__db::__anon18
femfs	./include/db.h	/^	} femfs;$/;"	m	struct:__db_txn	typeref:struct:__db_txn::__femfs
fetch	./include/db.h	2852;"	d
fhp	./include/db.h	/^	DB_FH		*fhp;$/;"	m	struct:__db_stream
fhp	./include/db.h	/^	DB_FH	  *fhp;			\/* Underlying file handle. *\/$/;"	m	struct:__db_mpoolfile
fhp	./include/db.h	/^	DB_FH	 *fhp;			\/* File handle. *\/$/;"	m	struct:__db_log_cursor
fid_gen	./include/db.h	/^	u_int32_t fid_gen;		\/* Rep generation number for fids. *\/$/;"	m	struct:__db
file	./include/db.h	/^	u_int32_t	file;		\/* File ID. *\/$/;"	m	struct:__db_lsn
file_name	./include/db.h	/^	char *file_name;	\/* File name. *\/$/;"	m	struct:__db_mpool_fstat
file_size	./include/db.h	/^	db_off_t	file_size;$/;"	m	struct:__db_stream
fileid	./include/db.h	/^			fileid[DB_FILE_ID_LEN];$/;"	m	struct:__db_mpoolfile
fileid	./include/db.h	/^	u_int8_t fileid[DB_FILE_ID_LEN];\/* File id. *\/$/;"	m	struct:__db_ilock
fileid	./include/db.h	/^	u_int8_t fileid[DB_FILE_ID_LEN];\/* File's unique ID for locking. *\/$/;"	m	struct:__db
fileid_reset	./include/db.h	/^	int  (*fileid_reset) __P((DB_ENV *, const char *, u_int32_t));$/;"	m	struct:__db_env
final_value	./learner.c	/^	accept_ack* final_value;$/;"	m	struct:instance	file:
firstkey	./include/db.h	2853;"	d
flags	./include/db.h	/^	u_int32_t	flags;		\/* DB_SEQ_XXX Flags. *\/$/;"	m	struct:__db_seq_record
flags	./include/db.h	/^	u_int32_t	flags;$/;"	m	struct:__db_stream
flags	./include/db.h	/^	u_int32_t	flags;$/;"	m	struct:__db_txn
flags	./include/db.h	/^	u_int32_t  flags;$/;"	m	struct:__db_mpoolfile
flags	./include/db.h	/^	u_int32_t flags;$/;"	m	struct:__db
flags	./include/db.h	/^	u_int32_t flags;$/;"	m	struct:__db_dbt
flags	./include/db.h	/^	u_int32_t flags;$/;"	m	struct:__db_env
flags	./include/db.h	/^	u_int32_t flags;$/;"	m	struct:__db_log_cursor
flags	./include/db.h	/^	u_int32_t flags;$/;"	m	struct:__db_repmgr_site
flags	./include/db.h	/^	u_int32_t flags;$/;"	m	struct:__db_site
flags	./include/db.h	/^	u_int32_t flags;$/;"	m	struct:__dbc
flags2	./include/db.h	/^	u_int32_t flags2;		   \/* Second flags word *\/$/;"	m	struct:__db
fmt	./include/db.h	/^	const char	fmt[4];$/;"	m	struct:__log_rec_spec
fname	./include/db.h	/^	char *fname, *dname;		\/* File\/database passed to DB->open. *\/$/;"	m	struct:__db
free_queue	./include/db.h	/^	} free_queue;$/;"	m	struct:__db	typeref:struct:__db::__cq_fq
ftype	./include/db.h	/^	int		ftype;		\/* File type. *\/$/;"	m	struct:__db_mpoolfile
gbytes	./include/db.h	/^	u_int32_t	gbytes, bytes;	\/* Maximum file size. *\/$/;"	m	struct:__db_mpoolfile
gen	./include/db.h	/^	u_int32_t	gen;		\/* Generation number of this lock. *\/$/;"	m	struct:__db_lock_u
get	./include/db.h	/^	int		(*get) __P((DB_SEQUENCE *,$/;"	m	struct:__db_sequence
get	./include/db.h	/^	int  (*get) __P((DB *, DB_TXN *, DBT *, DBT *, u_int32_t));$/;"	m	struct:__db
get	./include/db.h	/^	int (*get) __P((DBC *, DBT *, DBT *, u_int32_t));$/;"	m	struct:__dbc
get	./include/db.h	/^	int (*get) __P((DB_LOGC *, DB_LSN *, DBT *, u_int32_t));$/;"	m	struct:__db_log_cursor
get	./include/db.h	/^	int (*get)$/;"	m	struct:__db_mpoolfile
get_address	./include/db.h	/^	int (*get_address) __P((DB_SITE *, const char **, u_int *));$/;"	m	struct:__db_site
get_alloc	./include/db.h	/^	int  (*get_alloc) __P((DB *, void *(**)(size_t),$/;"	m	struct:__db
get_alloc	./include/db.h	/^	int  (*get_alloc) __P((DB_ENV *, void *(**)(size_t),$/;"	m	struct:__db_env
get_app_dispatch	./include/db.h	/^	int  (*get_app_dispatch)$/;"	m	struct:__db_env
get_append_recno	./include/db.h	/^	int  (*get_append_recno) __P((DB *, int (**)(DB *, DBT *, db_recno_t)));$/;"	m	struct:__db
get_assoc_flags	./include/db.h	/^	int  (*get_assoc_flags) __P((DB *, u_int32_t *));$/;"	m	struct:__db
get_backup_callbacks	./include/db.h	/^	int  (*get_backup_callbacks) __P((DB_ENV *,$/;"	m	struct:__db_env
get_backup_config	./include/db.h	/^	int  (*get_backup_config) __P((DB_ENV *, DB_BACKUP_CONFIG, u_int32_t *));$/;"	m	struct:__db_env
get_blob_dir	./include/db.h	/^	int  (*get_blob_dir) __P((DB *, const char **));$/;"	m	struct:__db
get_blob_dir	./include/db.h	/^	int  (*get_blob_dir) __P((DB_ENV *, const char **));$/;"	m	struct:__db_env
get_blob_sub_dir	./include/db.h	/^	int  (*get_blob_sub_dir) __P((DB *, const char **));$/;"	m	struct:__db
get_blob_threshold	./include/db.h	/^	int  (*get_blob_threshold) __P((DB *, u_int32_t *));$/;"	m	struct:__db
get_blob_threshold	./include/db.h	/^	int  (*get_blob_threshold) __P((DB_ENV*, u_int32_t *));$/;"	m	struct:__db_env
get_bt_compare	./include/db.h	/^	int  (*get_bt_compare)$/;"	m	struct:__db
get_bt_compress	./include/db.h	/^	int  (*get_bt_compress) __P((DB *,$/;"	m	struct:__db
get_bt_minkey	./include/db.h	/^	int  (*get_bt_minkey) __P((DB *, u_int32_t *));$/;"	m	struct:__db
get_bt_prefix	./include/db.h	/^	int  (*get_bt_prefix)$/;"	m	struct:__db
get_byteswapped	./include/db.h	/^	int  (*get_byteswapped) __P((DB *, int *));$/;"	m	struct:__db
get_cache_max	./include/db.h	/^	int  (*get_cache_max) __P((DB_ENV *, u_int32_t *, u_int32_t *));$/;"	m	struct:__db_env
get_cachesize	./include/db.h	/^	int		(*get_cachesize) __P((DB_SEQUENCE *, u_int32_t *));$/;"	m	struct:__db_sequence
get_cachesize	./include/db.h	/^	int  (*get_cachesize) __P((DB *, u_int32_t *, u_int32_t *, int *));$/;"	m	struct:__db
get_cachesize	./include/db.h	/^	int  (*get_cachesize) __P((DB_ENV *, u_int32_t *, u_int32_t *, int *));$/;"	m	struct:__db_env
get_clear_len	./include/db.h	/^	int (*get_clear_len) __P((DB_MPOOLFILE *, u_int32_t *));$/;"	m	struct:__db_mpoolfile
get_config	./include/db.h	/^	int (*get_config) __P((DB_SITE *, u_int32_t, u_int32_t *));$/;"	m	struct:__db_site
get_create_dir	./include/db.h	/^	int  (*get_create_dir) __P((DB *, const char **));$/;"	m	struct:__db
get_create_dir	./include/db.h	/^	int  (*get_create_dir) __P((DB_ENV *, const char **));$/;"	m	struct:__db_env
get_data_dirs	./include/db.h	/^	int  (*get_data_dirs) __P((DB_ENV *, const char ***));$/;"	m	struct:__db_env
get_data_len	./include/db.h	/^	int  (*get_data_len) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_db	./include/db.h	/^	int		(*get_db) __P((DB_SEQUENCE *, DB **));$/;"	m	struct:__db_sequence
get_dbname	./include/db.h	/^	int  (*get_dbname) __P((DB *, const char **, const char **));$/;"	m	struct:__db
get_dup_compare	./include/db.h	/^	int  (*get_dup_compare)$/;"	m	struct:__db
get_eid	./include/db.h	/^	int (*get_eid) __P((DB_SITE *, int *));$/;"	m	struct:__db_site
get_encrypt_flags	./include/db.h	/^	int  (*get_encrypt_flags) __P((DB *, u_int32_t *));$/;"	m	struct:__db
get_encrypt_flags	./include/db.h	/^	int  (*get_encrypt_flags) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_env	./include/db.h	/^	DB_ENV *(*get_env) __P((DB *));$/;"	m	struct:__db
get_errcall	./include/db.h	/^	void (*get_errcall) __P((DB *,$/;"	m	struct:__db
get_errcall	./include/db.h	/^	void (*get_errcall) __P((DB_ENV *,$/;"	m	struct:__db_env
get_errfile	./include/db.h	/^	void (*get_errfile) __P((DB *, FILE **));$/;"	m	struct:__db
get_errfile	./include/db.h	/^	void (*get_errfile) __P((DB_ENV *, FILE **));$/;"	m	struct:__db_env
get_errpfx	./include/db.h	/^	void (*get_errpfx) __P((DB *, const char **));$/;"	m	struct:__db
get_errpfx	./include/db.h	/^	void (*get_errpfx) __P((DB_ENV *, const char **));$/;"	m	struct:__db_env
get_feedback	./include/db.h	/^	int  (*get_feedback) __P((DB *, void (**)(DB *, int, int)));$/;"	m	struct:__db
get_feedback	./include/db.h	/^	int  (*get_feedback) __P((DB_ENV *, void (**)(DB_ENV *, int, int)));$/;"	m	struct:__db_env
get_fileid	./include/db.h	/^	int (*get_fileid) __P((DB_MPOOLFILE *, u_int8_t *));$/;"	m	struct:__db_mpoolfile
get_flags	./include/db.h	/^	int		(*get_flags) __P((DB_SEQUENCE *, u_int32_t *));$/;"	m	struct:__db_sequence
get_flags	./include/db.h	/^	int  (*get_flags) __P((DB *, u_int32_t *));$/;"	m	struct:__db
get_flags	./include/db.h	/^	int  (*get_flags) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_flags	./include/db.h	/^	int (*get_flags) __P((DB_MPOOLFILE *, u_int32_t *));$/;"	m	struct:__db_mpoolfile
get_ftype	./include/db.h	/^	int (*get_ftype) __P((DB_MPOOLFILE *, int *));$/;"	m	struct:__db_mpoolfile
get_h_compare	./include/db.h	/^	int  (*get_h_compare)$/;"	m	struct:__db
get_h_ffactor	./include/db.h	/^	int  (*get_h_ffactor) __P((DB *, u_int32_t *));$/;"	m	struct:__db
get_h_hash	./include/db.h	/^	int  (*get_h_hash)$/;"	m	struct:__db
get_h_nelem	./include/db.h	/^	int  (*get_h_nelem) __P((DB *, u_int32_t *));$/;"	m	struct:__db
get_heap_regionsize	./include/db.h	/^	int  (*get_heap_regionsize) __P((DB *, u_int32_t *));$/;"	m	struct:__db
get_heapsize	./include/db.h	/^	int  (*get_heapsize) __P((DB *, u_int32_t *, u_int32_t *));$/;"	m	struct:__db
get_home	./include/db.h	/^	int  (*get_home) __P((DB_ENV *, const char **));$/;"	m	struct:__db_env
get_intermediate_dir_mode	./include/db.h	/^	int  (*get_intermediate_dir_mode) __P((DB_ENV *, const char **));$/;"	m	struct:__db_env
get_isalive	./include/db.h	/^	int  (*get_isalive) __P((DB_ENV *,$/;"	m	struct:__db_env
get_key	./include/db.h	/^	int		(*get_key) __P((DB_SEQUENCE *, DBT *));$/;"	m	struct:__db_sequence
get_last_pgno	./include/db.h	/^	int (*get_last_pgno) __P((DB_MPOOLFILE *, db_pgno_t *));$/;"	m	struct:__db_mpoolfile
get_lg_bsize	./include/db.h	/^	int  (*get_lg_bsize) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_lg_dir	./include/db.h	/^	int  (*get_lg_dir) __P((DB_ENV *, const char **));$/;"	m	struct:__db_env
get_lg_filemode	./include/db.h	/^	int  (*get_lg_filemode) __P((DB_ENV *, int *));$/;"	m	struct:__db_env
get_lg_max	./include/db.h	/^	int  (*get_lg_max) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_lg_regionmax	./include/db.h	/^	int  (*get_lg_regionmax) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_lk_conflicts	./include/db.h	/^	int  (*get_lk_conflicts) __P((DB_ENV *, const u_int8_t **, int *));$/;"	m	struct:__db_env
get_lk_detect	./include/db.h	/^	int  (*get_lk_detect) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_lk_exclusive	./include/db.h	/^	int  (*get_lk_exclusive) __P((DB *, int *, int *));$/;"	m	struct:__db
get_lk_max_lockers	./include/db.h	/^	int  (*get_lk_max_lockers) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_lk_max_locks	./include/db.h	/^	int  (*get_lk_max_locks) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_lk_max_objects	./include/db.h	/^	int  (*get_lk_max_objects) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_lk_partitions	./include/db.h	/^	int  (*get_lk_partitions) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_lk_priority	./include/db.h	/^	int  (*get_lk_priority) __P((DB_ENV *, u_int32_t, u_int32_t *));$/;"	m	struct:__db_env
get_lk_tablesize	./include/db.h	/^	int  (*get_lk_tablesize) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_lorder	./include/db.h	/^	int  (*get_lorder) __P((DB *, int *));$/;"	m	struct:__db
get_lsn_offset	./include/db.h	/^	int (*get_lsn_offset) __P((DB_MPOOLFILE *, int32_t *));$/;"	m	struct:__db_mpoolfile
get_maxsize	./include/db.h	/^	int (*get_maxsize) __P((DB_MPOOLFILE *, u_int32_t *, u_int32_t *));$/;"	m	struct:__db_mpoolfile
get_memory_init	./include/db.h	/^	int  (*get_memory_init) __P((DB_ENV *, DB_MEM_CONFIG, u_int32_t *));$/;"	m	struct:__db_env
get_memory_max	./include/db.h	/^	int  (*get_memory_max) __P((DB_ENV *, u_int32_t *, u_int32_t *));$/;"	m	struct:__db_env
get_metadata_dir	./include/db.h	/^	int  (*get_metadata_dir) __P((DB_ENV *, const char **));$/;"	m	struct:__db_env
get_mp_max_openfd	./include/db.h	/^	int  (*get_mp_max_openfd) __P((DB_ENV *, int *));$/;"	m	struct:__db_env
get_mp_max_write	./include/db.h	/^	int  (*get_mp_max_write) __P((DB_ENV *, int *, db_timeout_t *));$/;"	m	struct:__db_env
get_mp_mmapsize	./include/db.h	/^	int  (*get_mp_mmapsize) __P((DB_ENV *, size_t *));$/;"	m	struct:__db_env
get_mp_mtxcount	./include/db.h	/^	int  (*get_mp_mtxcount) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_mp_pagesize	./include/db.h	/^	int  (*get_mp_pagesize) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_mp_tablesize	./include/db.h	/^	int  (*get_mp_tablesize) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_mpf	./include/db.h	/^	DB_MPOOLFILE *(*get_mpf) __P((DB *));$/;"	m	struct:__db
get_msgcall	./include/db.h	/^	void (*get_msgcall) __P((DB *,$/;"	m	struct:__db
get_msgcall	./include/db.h	/^	void (*get_msgcall)$/;"	m	struct:__db_env
get_msgfile	./include/db.h	/^	void (*get_msgfile) __P((DB *, FILE **));$/;"	m	struct:__db
get_msgfile	./include/db.h	/^	void (*get_msgfile) __P((DB_ENV *, FILE **));$/;"	m	struct:__db_env
get_multiple	./include/db.h	/^	int  (*get_multiple) __P((DB *));$/;"	m	struct:__db
get_name	./include/db.h	/^	int	  (*get_name) __P((DB_TXN *, const char **));$/;"	m	struct:__db_txn
get_open_flags	./include/db.h	/^	int  (*get_open_flags) __P((DB *, u_int32_t *));$/;"	m	struct:__db
get_open_flags	./include/db.h	/^	int  (*get_open_flags) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_pagesize	./include/db.h	/^	int  (*get_pagesize) __P((DB *, u_int32_t *));$/;"	m	struct:__db
get_partition_callback	./include/db.h	/^	int  (*get_partition_callback) __P((DB *,$/;"	m	struct:__db
get_partition_dirs	./include/db.h	/^	int  (*get_partition_dirs) __P((DB *, const char ***));$/;"	m	struct:__db
get_partition_keys	./include/db.h	/^	int  (*get_partition_keys) __P((DB *, u_int32_t *, DBT **));$/;"	m	struct:__db
get_pgcookie	./include/db.h	/^	int (*get_pgcookie) __P((DB_MPOOLFILE *, DBT *));$/;"	m	struct:__db_mpoolfile
get_priority	./include/db.h	/^	int	  (*get_priority) __P((DB_TXN *, u_int32_t *));$/;"	m	struct:__db_txn
get_priority	./include/db.h	/^	int  (*get_priority) __P((DB *, DB_CACHE_PRIORITY *));$/;"	m	struct:__db
get_priority	./include/db.h	/^	int (*get_priority) __P((DBC *, DB_CACHE_PRIORITY *));$/;"	m	struct:__dbc
get_priority	./include/db.h	/^	int (*get_priority) __P((DB_MPOOLFILE *, DB_CACHE_PRIORITY *));$/;"	m	struct:__db_mpoolfile
get_q_extentsize	./include/db.h	/^	int  (*get_q_extentsize) __P((DB *, u_int32_t *));$/;"	m	struct:__db
get_range	./include/db.h	/^	int		(*get_range) __P((DB_SEQUENCE *,$/;"	m	struct:__db_sequence
get_re_delim	./include/db.h	/^	int  (*get_re_delim) __P((DB *, int *));$/;"	m	struct:__db
get_re_len	./include/db.h	/^	int  (*get_re_len) __P((DB *, u_int32_t *));$/;"	m	struct:__db
get_re_pad	./include/db.h	/^	int  (*get_re_pad) __P((DB *, int *));$/;"	m	struct:__db
get_re_source	./include/db.h	/^	int  (*get_re_source) __P((DB *, const char **));$/;"	m	struct:__db
get_shm_key	./include/db.h	/^	int  (*get_shm_key) __P((DB_ENV *, long *));$/;"	m	struct:__db_env
get_thread_count	./include/db.h	/^	int  (*get_thread_count) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_thread_id_fn	./include/db.h	/^	int  (*get_thread_id_fn)$/;"	m	struct:__db_env
get_thread_id_string_fn	./include/db.h	/^	int  (*get_thread_id_string_fn) __P((DB_ENV *,$/;"	m	struct:__db_env
get_timeout	./include/db.h	/^	int  (*get_timeout) __P((DB_ENV *, db_timeout_t *, u_int32_t));$/;"	m	struct:__db_env
get_tmp_dir	./include/db.h	/^	int  (*get_tmp_dir) __P((DB_ENV *, const char **));$/;"	m	struct:__db_env
get_transactional	./include/db.h	/^	int  (*get_transactional) __P((DB *));$/;"	m	struct:__db
get_tx_max	./include/db.h	/^	int  (*get_tx_max) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
get_tx_timestamp	./include/db.h	/^	int  (*get_tx_timestamp) __P((DB_ENV *, time_t *));$/;"	m	struct:__db_env
get_type	./include/db.h	/^	int  (*get_type) __P((DB *, DBTYPE *));$/;"	m	struct:__db
get_verbose	./include/db.h	/^	int  (*get_verbose) __P((DB_ENV *, u_int32_t, int *));$/;"	m	struct:__db_env
gid	./include/db.h	/^	u_int8_t  gid[DB_GID_SIZE];	\/* Global transaction ID *\/$/;"	m	struct:__db_txn_active
gid	./include/db.h	/^	u_int8_t gid[DB_GID_SIZE];$/;"	m	struct:__db_preplist
greater	./include/db.h	/^	double greater;$/;"	m	struct:__key_range
h_internal	./include/db.h	/^	void	*h_internal;		\/* Hash access method. *\/$/;"	m	struct:__db
handle_lock	./include/db.h	/^	DB_LOCK	 handle_lock;		\/* Lock held on this handle. *\/$/;"	m	struct:__db
hash_bfree	./include/db.h	/^	uintmax_t hash_bfree;		\/* Bytes free on bucket pages. *\/$/;"	m	struct:__db_h_stat
hash_big_bfree	./include/db.h	/^	uintmax_t hash_big_bfree;	\/* Bytes free on big item pages. *\/$/;"	m	struct:__db_h_stat
hash_bigpages	./include/db.h	/^	u_int32_t hash_bigpages;	\/* Number of big key\/data pages. *\/$/;"	m	struct:__db_h_stat
hash_buckets	./include/db.h	/^	u_int32_t hash_buckets;		\/* Number of hash buckets. *\/$/;"	m	struct:__db_h_stat
hash_dup	./include/db.h	/^	u_int32_t hash_dup;		\/* Number of dup pages. *\/$/;"	m	struct:__db_h_stat
hash_dup_free	./include/db.h	/^	uintmax_t hash_dup_free;	\/* Bytes free on duplicate pages. *\/$/;"	m	struct:__db_h_stat
hash_ffactor	./include/db.h	/^	u_int32_t hash_ffactor;		\/* Fill factor specified at create. *\/$/;"	m	struct:__db_h_stat
hash_free	./include/db.h	/^	u_int32_t hash_free;		\/* Pages on the free list. *\/$/;"	m	struct:__db_h_stat
hash_magic	./include/db.h	/^	u_int32_t hash_magic;		\/* Magic number. *\/$/;"	m	struct:__db_h_stat
hash_metaflags	./include/db.h	/^	u_int32_t hash_metaflags;	\/* Metadata flags. *\/$/;"	m	struct:__db_h_stat
hash_nblobs	./include/db.h	/^	u_int32_t hash_nblobs;		\/* Number of blobs. *\/$/;"	m	struct:__db_h_stat
hash_ndata	./include/db.h	/^	u_int32_t hash_ndata;		\/* Number of data items. *\/$/;"	m	struct:__db_h_stat
hash_nkeys	./include/db.h	/^	u_int32_t hash_nkeys;		\/* Number of unique keys. *\/$/;"	m	struct:__db_h_stat
hash_overflows	./include/db.h	/^	u_int32_t hash_overflows;	\/* Number of overflow pages. *\/$/;"	m	struct:__db_h_stat
hash_ovfl_free	./include/db.h	/^	uintmax_t hash_ovfl_free;	\/* Bytes free on ovfl pages. *\/$/;"	m	struct:__db_h_stat
hash_pagecnt	./include/db.h	/^	u_int32_t hash_pagecnt;		\/* Page count. *\/$/;"	m	struct:__db_h_stat
hash_pagesize	./include/db.h	/^	u_int32_t hash_pagesize;	\/* Page size. *\/$/;"	m	struct:__db_h_stat
hash_version	./include/db.h	/^	u_int32_t hash_version;		\/* Version number. *\/$/;"	m	struct:__db_h_stat
hcreate	./include/db.h	2869;"	d
hdestroy	./include/db.h	2870;"	d
head	./carray.c	/^	int head;$/;"	m	struct:carray	file:
heap_internal	./include/db.h	/^	void	*heap_internal;		\/* Heap access method. *\/$/;"	m	struct:__db
heap_magic	./include/db.h	/^	u_int32_t heap_magic;		\/* Magic number. *\/$/;"	m	struct:__db_heap_stat
heap_metaflags	./include/db.h	/^	u_int32_t heap_metaflags;	\/* Metadata flags. *\/$/;"	m	struct:__db_heap_stat
heap_nblobs	./include/db.h	/^	u_int32_t heap_nblobs;		\/* Number of blobs. *\/$/;"	m	struct:__db_heap_stat
heap_nrecs	./include/db.h	/^	u_int32_t heap_nrecs;		\/* Number of records. *\/$/;"	m	struct:__db_heap_stat
heap_nregions	./include/db.h	/^	u_int32_t heap_nregions;	\/* Number of regions. *\/$/;"	m	struct:__db_heap_stat
heap_pagecnt	./include/db.h	/^	u_int32_t heap_pagecnt;		\/* Page count. *\/$/;"	m	struct:__db_heap_stat
heap_pagesize	./include/db.h	/^	u_int32_t heap_pagesize;	\/* Page size. *\/$/;"	m	struct:__db_heap_stat
heap_regionsize	./include/db.h	/^	u_int32_t heap_regionsize;	\/* Number of pages in a region. *\/$/;"	m	struct:__db_heap_stat
heap_version	./include/db.h	/^	u_int32_t heap_version;		\/* Version number. *\/$/;"	m	struct:__db_heap_stat
highest_iid_closed	./learner.c	/^	iid_t highest_iid_closed;$/;"	m	struct:learner	file:
highest_iid_seen	./learner.c	/^	iid_t highest_iid_seen;$/;"	m	struct:learner	file:
host	./include/db.h	/^	char *host;$/;"	m	struct:__db_repmgr_site
host	./include/db.h	/^	const char *host;$/;"	m	struct:__db_site
hsearch	./include/db.h	2871;"	d
id	./include/db.h	/^	u_int32_t (*id) __P((DB_TXN *));$/;"	m	struct:__db_txn
id	./proposer.c	/^	int id;$/;"	m	struct:proposer	file:
iid	./include/libpaxos_messages.h	/^	iid_t iid;$/;"	m	struct:accept_ack_t
iid	./include/libpaxos_messages.h	/^	iid_t iid;$/;"	m	struct:accept_req_t
iid	./include/libpaxos_messages.h	/^	iid_t iid;$/;"	m	struct:prepare_ack_t
iid	./include/libpaxos_messages.h	/^	iid_t iid;$/;"	m	struct:prepare_req_t
iid	./learner.c	/^	iid_t iid;$/;"	m	struct:instance	file:
iid	./proposer.c	/^	iid_t iid;$/;"	m	struct:instance	file:
iid_t	./include/paxos.h	/^typedef uint32_t iid_t;$/;"	t
indx	./include/db.h	/^	db_indx_t indx;			\/* Index in the offset table. *\/$/;"	m	struct:__db_heap_rid
initial_value	./include/db.h	/^	int		(*initial_value) __P((DB_SEQUENCE *, db_seq_t));$/;"	m	struct:__db_sequence
initialize_instances	./learner.c	/^initialize_instances(struct learner* l, int count)       \/\/初始化实例$/;"	f	file:
instance	./learner.c	/^struct instance$/;"	s	file:
instance	./proposer.c	/^struct instance$/;"	s	file:
instance_add_accept	./learner.c	/^instance_add_accept(struct instance* inst, accept_ack* ack)  \/\/添加新的accept_ack到实例中，索引为acceptor号，更新上次投票值  a-l$/;"	f	file:
instance_clear	./learner.c	/^instance_clear(struct instance* inst, int acceptors)  \/\/清除实例$/;"	f	file:
instance_find	./proposer.c	/^instance_find(struct carray* c, iid_t iid)         \/\/查找相应实例 $/;"	f	file:
instance_free	./learner.c	/^instance_free(struct instance* inst, int acceptors)          \/\/释放掉实例，先清空，后释放内存。$/;"	f	file:
instance_free	./proposer.c	/^instance_free(struct instance* inst)              \/\/释放实例$/;"	f	file:
instance_has_quorum	./learner.c	/^instance_has_quorum(struct learner* l, struct instance* inst)      \/\/检查一个实例是否关闭，也就是是否有多数派接受了同一个投票$/;"	f	file:
instance_has_timedout	./proposer.c	/^instance_has_timedout(struct instance* inst, struct timeval* now)   \/\/检查实例是否超时$/;"	f	file:
instance_match	./proposer.c	/^instance_match(void* arg, void* item)        \/\/两个实例匹配$/;"	f	file:
instance_new	./learner.c	/^instance_new(int acceptors)                          \/\/创建新的实例$/;"	f	file:
instance_new	./proposer.c	/^instance_new(iid_t iid, ballot_t ballot, int acceptors)       \/\/创建新实例$/;"	f	file:
instance_remove	./proposer.c	/^instance_remove(struct carray* c, struct instance* inst)   \/\/返回除去inst以外的队列$/;"	f	file:
instances	./learner.c	/^	struct carray* instances; 	\/* TODO instances should be hashtable *\/ \/\/实例队列$/;"	m	struct:learner	typeref:struct:learner::carray	file:
int_dispatch	./include/db.h	/^	int   (**int_dispatch) __P((ENV *, DBT *, DB_LSN *, db_recops, void *));$/;"	m	struct:__db_distab
int_size	./include/db.h	/^	size_t	int_size;$/;"	m	struct:__db_distab
intermediate_dir_mode	./include/db.h	/^	char	*intermediate_dir_mode;	\/* Intermediate directory perms *\/$/;"	m	struct:__db_env
internal	./include/db.h	/^	DBC_INTERNAL *internal;		\/* Access method private. *\/$/;"	m	struct:__dbc
is_alive	./include/db.h	/^	int   (*is_alive) __P((DB_ENV *, pid_t, db_threadid_t, u_int32_t));$/;"	m	struct:__db_env
is_bigendian	./include/db.h	/^	int  (*is_bigendian) __P((void));$/;"	m	struct:__db_env
is_final	./include/libpaxos_messages.h	/^	short int is_final;$/;"	m	struct:accept_ack_t
join	./include/db.h	/^	int  (*join) __P((DB *, DBC **, DBC **, u_int32_t));$/;"	m	struct:__db
join_queue	./include/db.h	/^	} join_queue;$/;"	m	struct:__db	typeref:struct:__db::__cq_jq
key	./include/db.h	/^	char *key;$/;"	m	struct:entry
key_range	./include/db.h	/^	int  (*key_range)$/;"	m	struct:__db
kids	./include/db.h	/^	} kids;$/;"	m	struct:__db_txn	typeref:struct:__db_txn::__kids
klinks	./include/db.h	/^	} klinks;			\/* Links of children in parent. *\/$/;"	m	struct:__db_txn	typeref:struct:__db_txn::__anon12
last_update_ballot	./learner.c	/^	ballot_t last_update_ballot;$/;"	m	struct:instance	file:
late_start	./learner.c	/^	int late_start;$/;"	m	struct:learner	file:
le_next	./include/db.h	/^		struct __db *le_next;$/;"	m	struct:__db::__anon16	typeref:struct:__db::__anon16::__db
le_prev	./include/db.h	/^		struct __db **le_prev;$/;"	m	struct:__db::__anon16	typeref:struct:__db::__anon16::__db
leader_announce	./include/libpaxos_messages.h	/^	leader_announce=64, \/\/Oracle to proposers$/;"	e	enum:pax_msg_code_e
learner	./learner.c	/^struct learner$/;"	s	file:
learner_catch_up	./include/paxos.h	/^	int learner_catch_up;$/;"	m	struct:paxos_config
learner_deliver_next	./learner.c	/^learner_deliver_next(struct learner* l)  \/\/清除当前实例，返回应答消息$/;"	f
learner_free	./learner.c	/^learner_free(struct learner* l)        \/\/释放learner$/;"	f
learner_get_current_instance	./learner.c	/^learner_get_current_instance(struct learner* l)$/;"	f	file:
learner_get_instance	./learner.c	/^learner_get_instance(struct learner* l, iid_t iid)       \/\/$/;"	f	file:
learner_has_holes	./learner.c	/^learner_has_holes(struct learner* l, iid_t* from, iid_t* to)       \/\/检查空洞$/;"	f
learner_instances	./include/paxos.h	/^	int learner_instances;$/;"	m	struct:paxos_config
learner_new	./learner.c	/^learner_new(int acceptors)          \/\/创建新的学习者$/;"	f
learner_receive_accept	./learner.c	/^learner_receive_accept(struct learner* l, accept_ack* ack)   \/\/获得接收消息$/;"	f
learner_update_instance	./learner.c	/^learner_update_instance(struct learner* l, accept_ack* ack)$/;"	f	file:
len	./include/db.h	/^	size_t		len;		\/* Length of mmap'd region. *\/$/;"	m	struct:__db_mpoolfile
len	./include/db.h	/^	u_int32_t len;			\/* Cursor: record length *\/$/;"	m	struct:__db_log_cursor
less	./include/db.h	/^	double less;$/;"	m	struct:__key_range
lg_bsize	./include/db.h	/^	u_int32_t	lg_bsize;	\/* Buffer size *\/$/;"	m	struct:__db_env
lg_fileid_init	./include/db.h	/^	u_int32_t	lg_fileid_init;	\/* Initial allocation for fname structs *\/$/;"	m	struct:__db_env
lg_filemode	./include/db.h	/^	int		lg_filemode;	\/* Log file permission mode *\/$/;"	m	struct:__db_env
lg_flags	./include/db.h	/^	u_int32_t	lg_flags;	\/* Log configuration *\/$/;"	m	struct:__db_env
lg_regionmax	./include/db.h	/^	u_int32_t	lg_regionmax;	\/* Region size *\/$/;"	m	struct:__db_env
lg_size	./include/db.h	/^	u_int32_t	lg_size;	\/* Log file size *\/$/;"	m	struct:__db_env
lh_first	./include/db.h	/^		struct __db *lh_first;$/;"	m	struct:__db::__anon15	typeref:struct:__db::__anon15::__db
lh_first	./include/db.h	/^		struct __db_foreign_info *lh_first;$/;"	m	struct:__db::__anon17	typeref:struct:__db::__anon17::__db_foreign_info
links	./include/db.h	/^	} links;			\/* Links transactions off manager. *\/$/;"	m	struct:__db_txn	typeref:struct:__db_txn::__anon8
links	./include/db.h	/^	} links;$/;"	m	struct:__dbc	typeref:struct:__dbc::__anon19
lk_conflicts	./include/db.h	/^	u_int8_t       *lk_conflicts;	\/* Two dimensional conflict matrix *\/$/;"	m	struct:__db_env
lk_detect	./include/db.h	/^	u_int32_t	lk_detect;	\/* Deadlock detect on all conflicts *\/$/;"	m	struct:__db_env
lk_init	./include/db.h	/^	u_int32_t	lk_init;	\/* Initial number of locks *\/$/;"	m	struct:__db_env
lk_init_lockers	./include/db.h	/^	u_int32_t	lk_init_lockers;\/* Initial number of lockers *\/$/;"	m	struct:__db_env
lk_init_objects	./include/db.h	/^	u_int32_t	lk_init_objects;\/* Initial number of locked objects *\/$/;"	m	struct:__db_env
lk_max	./include/db.h	/^	u_int32_t	lk_max;	\/* Maximum number of locks *\/$/;"	m	struct:__db_env
lk_max_lockers	./include/db.h	/^	u_int32_t	lk_max_lockers;\/* Maximum number of lockers *\/$/;"	m	struct:__db_env
lk_max_objects	./include/db.h	/^	u_int32_t	lk_max_objects;\/* Maximum number of locked objects *\/$/;"	m	struct:__db_env
lk_modes	./include/db.h	/^	int		lk_modes;	\/* Number of lock modes in table *\/$/;"	m	struct:__db_env
lk_partitions	./include/db.h	/^	u_int32_t	lk_partitions ;\/* Number of object partitions *\/$/;"	m	struct:__db_env
lk_timeout	./include/db.h	/^	db_timeout_t	lk_timeout;	\/* Lock timeout period *\/$/;"	m	struct:__db_env
lock	./include/db.h	/^	DB_LOCK		 lock;		\/* Lock returned. *\/$/;"	m	struct:__db_lockreq
lock	./include/db.h	/^	DB_LOCK_ILOCK lock;		\/* Object to be locked. *\/$/;"	m	struct:__dbc
lock_dbt	./include/db.h	/^	DBT	  lock_dbt;		\/* DBT referencing lock. *\/$/;"	m	struct:__dbc
lock_detect	./include/db.h	/^	int  (*lock_detect) __P((DB_ENV *, u_int32_t, u_int32_t, int *));$/;"	m	struct:__db_env
lock_get	./include/db.h	/^	int  (*lock_get) __P((DB_ENV *,$/;"	m	struct:__db_env
lock_id	./include/db.h	/^	int  (*lock_id) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
lock_id_free	./include/db.h	/^	int  (*lock_id_free) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
lock_put	./include/db.h	/^	int  (*lock_put) __P((DB_ENV *, DB_LOCK *));$/;"	m	struct:__db_env
lock_stat	./include/db.h	/^	int  (*lock_stat) __P((DB_ENV *, DB_LOCK_STAT **, u_int32_t));$/;"	m	struct:__db_env
lock_stat_print	./include/db.h	/^	int  (*lock_stat_print) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
lock_timeout	./include/db.h	/^	db_timeout_t	lock_timeout;	\/* Timeout for locks for this txn. *\/$/;"	m	struct:__db_txn
lock_vec	./include/db.h	/^	int  (*lock_vec) __P((DB_ENV *,$/;"	m	struct:__db_env
locker	./include/db.h	/^	DB_LOCKER	*locker;	\/* Locker for this txn. *\/$/;"	m	struct:__db_txn
locker	./include/db.h	/^	DB_LOCKER *locker;		\/* Locker for handle locking. *\/$/;"	m	struct:__db
locker	./include/db.h	/^	DB_LOCKER *locker;		\/* Locker for this operation. *\/$/;"	m	struct:__dbc
locker_t_size	./include/db.h	/^	u_int32_t	locker_t_size;	\/* Locker hash table size. *\/$/;"	m	struct:__db_env
log_archive	./include/db.h	/^	int  (*log_archive) __P((DB_ENV *, char **[], u_int32_t));$/;"	m	struct:__db_env
log_cursor	./include/db.h	/^	int  (*log_cursor) __P((DB_ENV *, DB_LOGC **, u_int32_t));$/;"	m	struct:__db_env
log_file	./include/db.h	/^	int  (*log_file) __P((DB_ENV *, const DB_LSN *, char *, size_t));$/;"	m	struct:__db_env
log_filename	./include/db.h	/^	FNAME *log_filename;		\/* File's naming info for logging. *\/$/;"	m	struct:__db
log_flush	./include/db.h	/^	int  (*log_flush) __P((DB_ENV *, const DB_LSN *));$/;"	m	struct:__db_env
log_get_config	./include/db.h	/^	int  (*log_get_config) __P((DB_ENV *, u_int32_t, int *));$/;"	m	struct:__db_env
log_printf	./include/db.h	/^	int  (*log_printf) __P((DB_ENV *, DB_TXN *, const char *, ...));$/;"	m	struct:__db_env
log_put	./include/db.h	/^	int  (*log_put) __P((DB_ENV *, DB_LSN *, const DBT *, u_int32_t));$/;"	m	struct:__db_env
log_put_record	./include/db.h	/^	int  (*log_put_record) __P((DB_ENV *, DB *, DB_TXN *, DB_LSN *,$/;"	m	struct:__db_env
log_read_record	./include/db.h	/^	int  (*log_read_record) __P((DB_ENV *, DB **,$/;"	m	struct:__db_env
log_rec_type_t	./include/db.h	/^} log_rec_type_t;$/;"	t	typeref:enum:__anon4
log_set_config	./include/db.h	/^	int  (*log_set_config) __P((DB_ENV *, u_int32_t, int));$/;"	m	struct:__db_env
log_stat	./include/db.h	/^	int  (*log_stat) __P((DB_ENV *, DB_LOG_STAT **, u_int32_t));$/;"	m	struct:__db_env
log_stat_print	./include/db.h	/^	int  (*log_stat_print) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
log_verify	./include/db.h	/^	int  (*log_verify) __P((DB_ENV *, const DB_LOG_VERIFY_CONFIG *));$/;"	m	struct:__db_env
logs	./include/db.h	/^	} logs;				\/* Links in memory log records. *\/$/;"	m	struct:__db_txn	typeref:struct:__db_txn::__anon11
lref	./include/db.h	/^	DB_LOCKER *lref;		\/* Reference to default locker. *\/$/;"	m	struct:__dbc
lsn	./include/db.h	/^	DB_LSN	  lsn;			\/* Cursor: LSN *\/$/;"	m	struct:__db_log_cursor
lsn	./include/db.h	/^	DB_LSN	  lsn;			\/* LSN when transaction began *\/$/;"	m	struct:__db_txn_active
lsn_offset	./include/db.h	/^	int32_t		lsn_offset;	\/* LSN offset in page. *\/$/;"	m	struct:__db_mpoolfile
lsn_reset	./include/db.h	/^	int  (*lsn_reset) __P((DB_ENV *, const char *, u_int32_t));$/;"	m	struct:__db_env
memory_max	./include/db.h	/^	roff_t		memory_max;	\/* Maximum region memory *\/$/;"	m	struct:__db_env
memp_fcreate	./include/db.h	/^	int  (*memp_fcreate) __P((DB_ENV *, DB_MPOOLFILE **, u_int32_t));$/;"	m	struct:__db_env
memp_register	./include/db.h	/^	int  (*memp_register) __P((DB_ENV *, int, int (*)(DB_ENV *, db_pgno_t,$/;"	m	struct:__db_env
memp_stat	./include/db.h	/^	int  (*memp_stat) __P((DB_ENV *,$/;"	m	struct:__db_env
memp_stat_print	./include/db.h	/^	int  (*memp_stat_print) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
memp_sync	./include/db.h	/^	int  (*memp_sync) __P((DB_ENV *, DB_LSN *));$/;"	m	struct:__db_env
memp_trickle	./include/db.h	/^	int  (*memp_trickle) __P((DB_ENV *, int, int *));$/;"	m	struct:__db_env
meta_pgno	./include/db.h	/^	db_pgno_t meta_pgno;		\/* Meta page number *\/$/;"	m	struct:__db
mfp	./include/db.h	/^	MPOOLFILE      *mfp;		\/* Underlying MPOOLFILE. *\/$/;"	m	struct:__db_mpoolfile
mgrp	./include/db.h	/^	DB_TXNMGR	*mgrp;		\/* Pointer to transaction manager. *\/$/;"	m	struct:__db_txn
mode	./include/db.h	/^	db_lockmode_t	 mode;		\/* Requested mode. *\/$/;"	m	struct:__db_lockreq
mode	./include/db.h	/^	db_lockmode_t	mode;		\/* mode of this lock. *\/$/;"	m	struct:__db_lock_u
mp_bytes	./include/db.h	/^	u_int32_t	mp_bytes;	\/* Cache size: bytes *\/$/;"	m	struct:__db_env
mp_gbytes	./include/db.h	/^	u_int32_t	mp_gbytes;	\/* Cache size: GB *\/$/;"	m	struct:__db_env
mp_max_bytes	./include/db.h	/^	u_int32_t	mp_max_bytes;	\/* Maximum cache size: bytes *\/$/;"	m	struct:__db_env
mp_max_gbytes	./include/db.h	/^	u_int32_t	mp_max_gbytes;	\/* Maximum cache size: GB *\/$/;"	m	struct:__db_env
mp_maxopenfd	./include/db.h	/^	int		mp_maxopenfd;	\/* Maximum open file descriptors *\/$/;"	m	struct:__db_env
mp_maxwrite	./include/db.h	/^	int		mp_maxwrite;	\/* Maximum buffers to write *\/$/;"	m	struct:__db_env
mp_maxwrite_sleep	./include/db.h	/^	db_timeout_t	mp_maxwrite_sleep;$/;"	m	struct:__db_env
mp_mmapsize	./include/db.h	/^	size_t		mp_mmapsize;	\/* Maximum file size for mmap *\/$/;"	m	struct:__db_env
mp_mtxcount	./include/db.h	/^	u_int32_t	mp_mtxcount;	\/* Number of mutexs *\/$/;"	m	struct:__db_env
mp_ncache	./include/db.h	/^	u_int		mp_ncache;	\/* Initial number of cache regions *\/$/;"	m	struct:__db_env
mp_pagesize	./include/db.h	/^	u_int32_t	mp_pagesize;	\/* Average page size *\/$/;"	m	struct:__db_env
mp_tablesize	./include/db.h	/^	u_int32_t	mp_tablesize;	\/* Approximate hash table size *\/$/;"	m	struct:__db_env
mpf	./include/db.h	/^	DB_MPOOLFILE *mpf;		\/* Backing buffer pool. *\/$/;"	m	struct:__db
mtx_db_env	./include/db.h	/^	db_mutex_t mtx_db_env;		\/* DB_ENV structure mutex *\/$/;"	m	struct:__db_env
mtx_seq	./include/db.h	/^	db_mutex_t	mtx_seq;	\/* Mutex if sequence is threaded. *\/$/;"	m	struct:__db_sequence
mutex	./include/db.h	/^	db_mutex_t mutex;		\/* Synchronization for free threading *\/$/;"	m	struct:__db
mutex_align	./include/db.h	/^	u_int32_t	mutex_align;	\/* Mutex alignment *\/$/;"	m	struct:__db_env
mutex_alloc	./include/db.h	/^	int  (*mutex_alloc) __P((DB_ENV *, u_int32_t, db_mutex_t *));$/;"	m	struct:__db_env
mutex_cnt	./include/db.h	/^	u_int32_t	mutex_cnt;	\/* Number of mutexes to configure *\/$/;"	m	struct:__db_env
mutex_free	./include/db.h	/^	int  (*mutex_free) __P((DB_ENV *, db_mutex_t));$/;"	m	struct:__db_env
mutex_get_align	./include/db.h	/^	int  (*mutex_get_align) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
mutex_get_increment	./include/db.h	/^	int  (*mutex_get_increment) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
mutex_get_init	./include/db.h	/^	int  (*mutex_get_init) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
mutex_get_max	./include/db.h	/^	int  (*mutex_get_max) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
mutex_get_tas_spins	./include/db.h	/^	int  (*mutex_get_tas_spins) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
mutex_inc	./include/db.h	/^	u_int32_t	mutex_inc;	\/* Number of mutexes to add *\/$/;"	m	struct:__db_env
mutex_lock	./include/db.h	/^	int  (*mutex_lock) __P((DB_ENV *, db_mutex_t));$/;"	m	struct:__db_env
mutex_max	./include/db.h	/^	u_int32_t	mutex_max;	\/* Max number of mutexes *\/$/;"	m	struct:__db_env
mutex_set_align	./include/db.h	/^	int  (*mutex_set_align) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
mutex_set_increment	./include/db.h	/^	int  (*mutex_set_increment) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
mutex_set_init	./include/db.h	/^	int  (*mutex_set_init) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
mutex_set_max	./include/db.h	/^	int  (*mutex_set_max) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
mutex_set_tas_spins	./include/db.h	/^	int  (*mutex_set_tas_spins) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
mutex_stat	./include/db.h	/^	int  (*mutex_stat) __P((DB_ENV *, DB_MUTEX_STAT **, u_int32_t));$/;"	m	struct:__db_env
mutex_stat_print	./include/db.h	/^	int  (*mutex_stat_print) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
mutex_tas_spins	./include/db.h	/^	u_int32_t	mutex_tas_spins;\/* Test-and-set spin count *\/$/;"	m	struct:__db_env
mutex_unlock	./include/db.h	/^	int  (*mutex_unlock) __P((DB_ENV *, db_mutex_t));$/;"	m	struct:__db_env
mvcc_ref	./include/db.h	/^	u_int32_t mvcc_ref;		\/* MVCC reference count *\/$/;"	m	struct:__db_txn_active
my_cursors	./include/db.h	/^	} my_cursors;$/;"	m	struct:__db_txn	typeref:struct:__db_txn::__my_cursors
my_rdata	./include/db.h	/^	DBT	  my_rdata;		\/* Space for returned data. *\/$/;"	m	struct:__dbc
my_rdata	./include/db.h	/^	DBT	 my_rdata;		\/* Data. *\/$/;"	m	struct:__db
my_rkey	./include/db.h	/^	DBT	  my_rkey;		\/* Space for returned [primary] key. *\/$/;"	m	struct:__dbc
my_rkey	./include/db.h	/^	DBT	 my_rkey;		\/* [Primary] key. *\/$/;"	m	struct:__db
my_rskey	./include/db.h	/^	DBT	  my_rskey;		\/* Space for returned secondary key. *\/$/;"	m	struct:__dbc
my_rskey	./include/db.h	/^	DBT	 my_rskey;		\/* Secondary key. *\/$/;"	m	struct:__db
mylock	./include/db.h	/^	DB_LOCK	  mylock;		\/* CDB lock held on this cursor. *\/$/;"	m	struct:__dbc
name	./include/db.h	/^	char		*name;		\/* Transaction name. *\/$/;"	m	struct:__db_txn
name	./include/db.h	/^	char	  name[51];		\/* 50 bytes of name, nul termination *\/$/;"	m	struct:__db_txn_active
name	./include/db.h	/^	const char 	*name;$/;"	m	struct:__log_rec_spec
ndx	./include/db.h	/^	u_int32_t	ndx;		\/* Index of the object referenced by$/;"	m	struct:__db_lock_u
next_prepare_iid	./proposer.c	/^	iid_t next_prepare_iid;$/;"	m	struct:proposer	file:
next_timedout	./proposer.c	/^next_timedout(struct carray* c, int* i, struct timeval* t)        \/\/返回超时实例$/;"	f	file:
nextkey	./include/db.h	2854;"	d
obj	./include/db.h	/^	DBT		*obj;		\/* Object being locked. *\/$/;"	m	struct:__db_lockreq
object_t_size	./include/db.h	/^	u_int32_t	object_t_size;	\/* Object hash table size. *\/$/;"	m	struct:__db_env
off	./include/db.h	/^	roff_t		off;		\/* Offset of the lock in the region *\/$/;"	m	struct:__db_lock_u
offset	./include/db.h	/^	u_int32_t	offset;		\/* File offset. *\/$/;"	m	struct:__db_lsn
offset	./include/db.h	/^	u_int32_t	offset;$/;"	m	struct:__log_rec_spec
op	./include/db.h	/^	db_lockop_t	 op;		\/* Operation. *\/$/;"	m	struct:__db_lockreq
open	./include/db.h	/^	int		(*open) __P((DB_SEQUENCE *,$/;"	m	struct:__db_sequence
open	./include/db.h	/^	int  (*open) __P((DB *,$/;"	m	struct:__db
open	./include/db.h	/^	int  (*open) __P((DB_ENV *, const char *, u_int32_t, int));$/;"	m	struct:__db_env
open	./include/db.h	/^	int (*open) __P((DB_MPOOLFILE *, const char *, u_int32_t, int, size_t));$/;"	m	struct:__db_mpoolfile
open_flags	./include/db.h	/^	u_int32_t open_flags;		\/* Flags passed to DB->open. *\/$/;"	m	struct:__db
orig_flags	./include/db.h	/^	u_int32_t orig_flags;		   \/* Flags at  open, for refresh *\/$/;"	m	struct:__db
orig_flags2	./include/db.h	/^	u_int32_t orig_flags2;		   \/* Second flags word; for refresh *\/ $/;"	m	struct:__db
p_internal	./include/db.h	/^	void	*p_internal;		\/* Partition informaiton. *\/$/;"	m	struct:__db
p_lsn	./include/db.h	/^	DB_LSN    p_lsn;		\/* Persist LSN. *\/$/;"	m	struct:__db_log_cursor
p_version	./include/db.h	/^	u_int32_t p_version;		\/* Persist version. *\/$/;"	m	struct:__db_log_cursor
parent	./include/db.h	/^	DB_TXN		*parent;	\/* Pointer to transaction's parent. *\/$/;"	m	struct:__db_txn
parentid	./include/db.h	/^	u_int32_t parentid;		\/* Transaction ID of parent *\/$/;"	m	struct:__db_txn_active
passwd	./include/db.h	/^	char	*passwd;		\/* Cryptography support *\/$/;"	m	struct:__db_env
passwd_len	./include/db.h	/^	size_t	 passwd_len;$/;"	m	struct:__db_env
pax_msg_code_e	./include/libpaxos_messages.h	/^typedef enum pax_msg_code_e {$/;"	g
paxos_config	./include/paxos.h	/^struct paxos_config$/;"	s
paxos_config	./paxos.c	/^struct paxos_config paxos_config =$/;"	v	typeref:struct:paxos_config
paxos_log	./paxos.c	/^paxos_log(int level, const char* format, va_list ap)     \/\/记录日志$/;"	f
paxos_log_debug	./paxos.c	/^paxos_log_debug(const char* format, ...)            \/\/记录调试日志$/;"	f
paxos_log_error	./paxos.c	/^paxos_log_error(const char* format, ...)    \/\/记录错误日志$/;"	f
paxos_log_info	./paxos.c	/^paxos_log_info(const char* format, ...)        \/\/记录消息日志$/;"	f
paxos_msg	./include/libpaxos_messages.h	/^}  __attribute__((packed)) paxos_msg;$/;"	t	typeref:struct:paxos_msg_t
paxos_msg_code	./include/libpaxos_messages.h	/^} paxos_msg_code;$/;"	t	typeref:enum:pax_msg_code_e
paxos_msg_t	./include/libpaxos_messages.h	/^typedef struct paxos_msg_t {$/;"	s
paxos_quorum	./paxos.c	/^paxos_quorum(int acceptors)                        \/\/多数派$/;"	f
pgcookie	./include/db.h	/^	DBT	       *pgcookie;	\/* Byte-string passed to pgin\/pgout. *\/$/;"	m	struct:__db_mpoolfile
pget	./include/db.h	/^	int  (*pget) __P((DB *, DB_TXN *, DBT *, DBT *, DBT *, u_int32_t));$/;"	m	struct:__db
pget	./include/db.h	/^	int (*pget) __P((DBC *, DBT *, DBT *, DBT *, u_int32_t));$/;"	m	struct:__dbc
pgno	./include/db.h	/^	db_pgno_t pgno;			\/* Page being locked. *\/$/;"	m	struct:__db_ilock
pgno	./include/db.h	/^	db_pgno_t pgno;			\/* Page number. *\/$/;"	m	struct:__db_heap_rid
pgsize	./include/db.h	/^	u_int32_t pgsize;		\/* Database logical page size. *\/$/;"	m	struct:__db
pi	./proposer.c	/^	int pi, ai;$/;"	m	struct:timeout_iterator	file:
pid	./include/db.h	/^	pid_t     pid;			\/* Process owning txn ID *\/$/;"	m	struct:__db_txn_active
pinref	./include/db.h	/^	u_int32_t pinref;		\/* Pinned block reference count. *\/$/;"	m	struct:__db_mpoolfile
port	./include/db.h	/^	u_int port;$/;"	m	struct:__db_repmgr_site
port	./include/db.h	/^	u_int port;$/;"	m	struct:__db_site
prdbt	./include/db.h	/^	int  (*prdbt) __P((DBT *, int, const char *, void *,$/;"	m	struct:__db_env
prepare	./include/db.h	/^	int	  (*prepare) __P((DB_TXN *, u_int8_t *));$/;"	m	struct:__db_txn
prepare_ack	./include/libpaxos_messages.h	/^} prepare_ack;$/;"	t	typeref:struct:prepare_ack_t
prepare_ack_t	./include/libpaxos_messages.h	/^typedef struct prepare_ack_t {$/;"	s
prepare_acks	./include/libpaxos_messages.h	/^	prepare_acks=2,     \/\/Phase 1b, A->P$/;"	e	enum:pax_msg_code_e
prepare_instances	./proposer.c	/^	struct carray* prepare_instances; \/* Instances waiting for prepare acks 接收prepare回复的实例 *\/$/;"	m	struct:proposer	typeref:struct:proposer::carray	file:
prepare_preempt	./proposer.c	/^prepare_preempt(struct proposer* p, struct instance* inst, prepare_req* out)     \/\/更改提案号到一个更大的，重写发送req请求$/;"	f
prepare_req	./include/libpaxos_messages.h	/^} prepare_req;$/;"	t	typeref:struct:prepare_req_t
prepare_req_t	./include/libpaxos_messages.h	/^typedef struct prepare_req_t {$/;"	s
prepare_reqs	./include/libpaxos_messages.h	/^	prepare_reqs=1,     \/\/Phase 1a, P->A$/;"	e	enum:pax_msg_code_e
preserve_fid	./include/db.h	/^	int	 preserve_fid;		\/* Do not free fileid on close. *\/$/;"	m	struct:__db
prev	./include/db.h	/^	u_int32_t prev;			\/* Cursor: previous record's offset *\/$/;"	m	struct:__db_log_cursor
priority	./include/db.h	/^	DB_CACHE_PRIORITY priority;	\/* Database priority in cache. *\/$/;"	m	struct:__db
priority	./include/db.h	/^	DB_CACHE_PRIORITY priority;	\/* Priority in cache. *\/$/;"	m	struct:__dbc
priority	./include/db.h	/^	int32_t		priority;	\/* Cache priority. *\/$/;"	m	struct:__db_mpoolfile
priority	./include/db.h	/^	u_int32_t priority;		\/* Deadlock resolution priority *\/$/;"	m	struct:__db_txn_active
proposer	./proposer.c	/^	struct proposer* proposer;$/;"	m	struct:timeout_iterator	typeref:struct:timeout_iterator::proposer	file:
proposer	./proposer.c	/^struct proposer $/;"	s	file:
proposer_accept	./proposer.c	/^proposer_accept(struct proposer* p)   \/\/发起accept请求$/;"	f
proposer_free	./proposer.c	/^proposer_free(struct proposer* p)                  \/\/释放proposer$/;"	f
proposer_new	./proposer.c	/^proposer_new(int id, int acceptors)       \/\/创建新的proposer$/;"	f
proposer_next_ballot	./proposer.c	/^proposer_next_ballot(struct proposer* p, ballot_t b)    \/\/下一个提案号$/;"	f	file:
proposer_preexec_window	./include/paxos.h	/^	int proposer_preexec_window;$/;"	m	struct:paxos_config
proposer_prepare	./proposer.c	/^proposer_prepare(struct proposer* p, prepare_req* out)       \/\/propare请求$/;"	f
proposer_prepared_count	./proposer.c	/^proposer_prepared_count(struct proposer* p)            \/\/prepare实例的数量$/;"	f
proposer_propose	./proposer.c	/^proposer_propose(struct proposer* p, char* value, size_t size)   \/\/提出propose$/;"	f
proposer_receive_accept_ack	./proposer.c	/^proposer_receive_accept_ack(struct proposer* p, accept_ack* ack, prepare_req* out)       \/\/接受acceptor对于accept请求的回复$/;"	f
proposer_receive_prepare_ack	./proposer.c	/^proposer_receive_prepare_ack(struct proposer* p, prepare_ack* ack,      \/\/接受准备请求的回复$/;"	f
proposer_timeout	./include/paxos.h	/^	int proposer_timeout;$/;"	m	struct:paxos_config
proposer_timeout_iterator	./proposer.c	/^proposer_timeout_iterator(struct proposer* p)                   \/\/超时迭代器$/;"	f
put	./include/db.h	/^	int  (*put) __P((DB *, DB_TXN *, DBT *, DBT *, u_int32_t));$/;"	m	struct:__db
put	./include/db.h	/^	int (*put) __P((DBC *, DBT *, DBT *, u_int32_t));$/;"	m	struct:__dbc
put	./include/db.h	/^	int (*put) __P((DB_MPOOLFILE *, void *, DB_CACHE_PRIORITY, u_int32_t));$/;"	m	struct:__db_mpoolfile
q	./include/db.h	/^	} q;				\/* Linked list of DB_MPOOLFILE's. *\/$/;"	m	struct:__db_mpoolfile	typeref:struct:__db_mpoolfile::__anon6
q_internal	./include/db.h	/^	void	*q_internal;		\/* Queue access method. *\/$/;"	m	struct:__db
qs_cur_recno	./include/db.h	/^	u_int32_t qs_cur_recno;		\/* Next available record number. *\/$/;"	m	struct:__db_qam_stat
qs_extentsize	./include/db.h	/^	u_int32_t qs_extentsize;	\/* Pages per extent. *\/$/;"	m	struct:__db_qam_stat
qs_first_recno	./include/db.h	/^	u_int32_t qs_first_recno;	\/* First not deleted record. *\/$/;"	m	struct:__db_qam_stat
qs_magic	./include/db.h	/^	u_int32_t qs_magic;		\/* Magic number. *\/$/;"	m	struct:__db_qam_stat
qs_metaflags	./include/db.h	/^	u_int32_t qs_metaflags;		\/* Metadata flags. *\/$/;"	m	struct:__db_qam_stat
qs_ndata	./include/db.h	/^	u_int32_t qs_ndata;		\/* Number of data items. *\/$/;"	m	struct:__db_qam_stat
qs_nkeys	./include/db.h	/^	u_int32_t qs_nkeys;		\/* Number of unique keys. *\/$/;"	m	struct:__db_qam_stat
qs_pages	./include/db.h	/^	u_int32_t qs_pages;		\/* Data pages. *\/$/;"	m	struct:__db_qam_stat
qs_pagesize	./include/db.h	/^	u_int32_t qs_pagesize;		\/* Page size. *\/$/;"	m	struct:__db_qam_stat
qs_pgfree	./include/db.h	/^	u_int32_t qs_pgfree;		\/* Bytes free in data pages. *\/$/;"	m	struct:__db_qam_stat
qs_re_len	./include/db.h	/^	u_int32_t qs_re_len;		\/* Fixed-length record length. *\/$/;"	m	struct:__db_qam_stat
qs_re_pad	./include/db.h	/^	u_int32_t qs_re_pad;		\/* Fixed-length record pad. *\/$/;"	m	struct:__db_qam_stat
qs_version	./include/db.h	/^	u_int32_t qs_version;		\/* Version number. *\/$/;"	m	struct:__db_qam_stat
quorum	./include/quorum.h	/^	int quorum;$/;"	m	struct:quorum
quorum	./include/quorum.h	/^struct quorum$/;"	s
quorum	./learner.c	/^	int quorum;$/;"	m	struct:learner	file:
quorum	./proposer.c	/^	struct quorum quorum;$/;"	m	struct:instance	typeref:struct:instance::quorum	file:
quorum_add	./quorum.c	/^quorum_add(struct quorum* q, int id)        \/\/多数派中添加$/;"	f
quorum_clear	./quorum.c	/^quorum_clear(struct quorum* q)$/;"	f
quorum_destroy	./quorum.c	/^quorum_destroy(struct quorum* q)$/;"	f
quorum_init	./quorum.c	/^quorum_init(struct quorum* q, int acceptors)$/;"	f
quorum_reached	./quorum.c	/^quorum_reached(struct quorum* q)        \/\/判断是否达到多数派$/;"	f
rdata	./include/db.h	/^	DBT	 *rdata;		\/* Returned data. *\/$/;"	m	struct:__dbc
read	./include/db.h	/^	int  (*read) __P((DB_STREAM *, DBT *, db_off_t, u_int32_t, u_int32_t));$/;"	m	struct:__db_stream
read_lsn	./include/db.h	/^	DB_LSN	  read_lsn;		\/* Read LSN for MVCC *\/$/;"	m	struct:__db_txn_active
record_buf	./storage_bdb.c	/^	char record_buf[PAXOS_MAX_VALUE_SIZE];$/;"	m	struct:storage	file:
records	./storage_mem.c	/^	acceptor_record *records[MAX_RECORDS];$/;"	m	struct:storage	file:
ref	./include/db.h	/^	u_int32_t  ref;			\/* Reference count. *\/$/;"	m	struct:__db_mpoolfile
registry	./include/db.h	/^	DB_FH		*registry;	\/* DB_REGISTER file handle *\/$/;"	m	struct:__db_env
registry_off	./include/db.h	/^	u_int32_t	registry_off;	\/*$/;"	m	struct:__db_env
remove	./include/db.h	/^	int		(*remove) __P((DB_SEQUENCE *, DB_TXN *, u_int32_t));$/;"	m	struct:__db_sequence
remove	./include/db.h	/^	int  (*remove) __P((DB *, const char *, const char *, u_int32_t));$/;"	m	struct:__db
remove	./include/db.h	/^	int  (*remove) __P((DB_ENV *, const char *, u_int32_t));$/;"	m	struct:__db_env
remove	./include/db.h	/^	int (*remove) __P((DB_SITE *));$/;"	m	struct:__db_site
rename	./include/db.h	/^	int  (*rename) __P((DB *,$/;"	m	struct:__db
rep_elect	./include/db.h	/^	int  (*rep_elect) __P((DB_ENV *, u_int32_t, u_int32_t, u_int32_t));$/;"	m	struct:__db_env
rep_flush	./include/db.h	/^	int  (*rep_flush) __P((DB_ENV *));$/;"	m	struct:__db_env
rep_get_clockskew	./include/db.h	/^	int  (*rep_get_clockskew) __P((DB_ENV *, u_int32_t *, u_int32_t *));$/;"	m	struct:__db_env
rep_get_config	./include/db.h	/^	int  (*rep_get_config) __P((DB_ENV *, u_int32_t, int *));$/;"	m	struct:__db_env
rep_get_limit	./include/db.h	/^	int  (*rep_get_limit) __P((DB_ENV *, u_int32_t *, u_int32_t *));$/;"	m	struct:__db_env
rep_get_nsites	./include/db.h	/^	int  (*rep_get_nsites) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
rep_get_priority	./include/db.h	/^	int  (*rep_get_priority) __P((DB_ENV *, u_int32_t *));$/;"	m	struct:__db_env
rep_get_request	./include/db.h	/^	int  (*rep_get_request) __P((DB_ENV *, u_int32_t *, u_int32_t *));$/;"	m	struct:__db_env
rep_get_timeout	./include/db.h	/^	int  (*rep_get_timeout) __P((DB_ENV *, int, u_int32_t *));$/;"	m	struct:__db_env
rep_process_message	./include/db.h	/^	int  (*rep_process_message)$/;"	m	struct:__db_env
rep_set_clockskew	./include/db.h	/^	int  (*rep_set_clockskew) __P((DB_ENV *, u_int32_t, u_int32_t));$/;"	m	struct:__db_env
rep_set_config	./include/db.h	/^	int  (*rep_set_config) __P((DB_ENV *, u_int32_t, int));$/;"	m	struct:__db_env
rep_set_limit	./include/db.h	/^	int  (*rep_set_limit) __P((DB_ENV *, u_int32_t, u_int32_t));$/;"	m	struct:__db_env
rep_set_nsites	./include/db.h	/^	int  (*rep_set_nsites) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
rep_set_priority	./include/db.h	/^	int  (*rep_set_priority) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
rep_set_request	./include/db.h	/^	int  (*rep_set_request) __P((DB_ENV *, u_int32_t, u_int32_t));$/;"	m	struct:__db_env
rep_set_timeout	./include/db.h	/^	int  (*rep_set_timeout) __P((DB_ENV *, int, db_timeout_t));$/;"	m	struct:__db_env
rep_set_transport	./include/db.h	/^	int  (*rep_set_transport) __P((DB_ENV *, int, int (*)(DB_ENV *,$/;"	m	struct:__db_env
rep_set_view	./include/db.h	/^	int  (*rep_set_view) __P((DB_ENV *, int (*)(DB_ENV *,$/;"	m	struct:__db_env
rep_start	./include/db.h	/^	int  (*rep_start) __P((DB_ENV *, DBT *, u_int32_t));$/;"	m	struct:__db_env
rep_stat	./include/db.h	/^	int  (*rep_stat) __P((DB_ENV *, DB_REP_STAT **, u_int32_t));$/;"	m	struct:__db_env
rep_stat_print	./include/db.h	/^	int  (*rep_stat_print) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
rep_sync	./include/db.h	/^	int  (*rep_sync) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
repeat_reqs	./include/libpaxos_messages.h	/^	repeat_reqs=16,     \/\/For progress, L -> A$/;"	e	enum:pax_msg_code_e
repmgr_channel	./include/db.h	/^	int  (*repmgr_channel) __P((DB_ENV *, int, DB_CHANNEL **, u_int32_t));$/;"	m	struct:__db_env
repmgr_get_ack_policy	./include/db.h	/^	int  (*repmgr_get_ack_policy) __P((DB_ENV *, int *));$/;"	m	struct:__db_env
repmgr_get_incoming_queue_max	./include/db.h	/^	int  (*repmgr_get_incoming_queue_max)$/;"	m	struct:__db_env
repmgr_local_site	./include/db.h	/^	int  (*repmgr_local_site) __P((DB_ENV *, DB_SITE **));$/;"	m	struct:__db_env
repmgr_msg_dispatch	./include/db.h	/^	int  (*repmgr_msg_dispatch) __P((DB_ENV *,$/;"	m	struct:__db_env
repmgr_set_ack_policy	./include/db.h	/^	int  (*repmgr_set_ack_policy) __P((DB_ENV *, int));$/;"	m	struct:__db_env
repmgr_set_incoming_queue_max	./include/db.h	/^	int  (*repmgr_set_incoming_queue_max)$/;"	m	struct:__db_env
repmgr_site	./include/db.h	/^	int  (*repmgr_site)$/;"	m	struct:__db_env
repmgr_site_by_eid	./include/db.h	/^	int  (*repmgr_site_by_eid) __P((DB_ENV *, int, DB_SITE**));$/;"	m	struct:__db_env
repmgr_site_list	./include/db.h	/^	int  (*repmgr_site_list) __P((DB_ENV *, u_int *, DB_REPMGR_SITE **));$/;"	m	struct:__db_env
repmgr_start	./include/db.h	/^	int  (*repmgr_start) __P((DB_ENV *, int, u_int32_t));$/;"	m	struct:__db_env
repmgr_stat	./include/db.h	/^	int  (*repmgr_stat) __P((DB_ENV *, DB_REPMGR_STAT **, u_int32_t));$/;"	m	struct:__db_env
repmgr_stat_print	./include/db.h	/^	int  (*repmgr_stat_print) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
rkey	./include/db.h	/^	DBT	 *rkey;			\/* Returned [primary] key. *\/$/;"	m	struct:__dbc
roff_t	./include/db.h	/^typedef	db_size_t	roff_t;$/;"	t
rskey	./include/db.h	/^	DBT	 *rskey;		\/* Returned secondary key. *\/$/;"	m	struct:__dbc
s_assoc_flags	./include/db.h	/^	u_int32_t s_assoc_flags;$/;"	m	struct:__db
s_callback	./include/db.h	/^	int	(*s_callback) __P((DB *, const DBT *, const DBT *, DBT *));$/;"	m	struct:__db
s_foreign	./include/db.h	/^	DB      *s_foreign;$/;"	m	struct:__db
s_links	./include/db.h	/^	} s_links;$/;"	m	struct:__db	typeref:struct:__db::__anon16
s_primary	./include/db.h	/^	DB	*s_primary;$/;"	m	struct:__db
s_refcnt	./include/db.h	/^	u_int32_t s_refcnt;$/;"	m	struct:__db
s_secondaries	./include/db.h	/^	} s_secondaries;$/;"	m	struct:__db	typeref:struct:__db::__anon15
saved_open_fhp	./include/db.h	/^	DB_FH	*saved_open_fhp;	\/* Saved file handle. *\/$/;"	m	struct:__db
send_msg	./include/db.h	/^	int (*send_msg) __P((DB_CHANNEL *, DBT *, u_int32_t, u_int32_t));$/;"	m	struct:__db_channel
send_request	./include/db.h	/^	int (*send_request) __P((DB_CHANNEL *,$/;"	m	struct:__db_channel
seq_cache_size	./include/db.h	/^	u_int32_t	seq_cache_size; \/* Number of values cached. *\/$/;"	m	struct:__db_sequence
seq_data	./include/db.h	/^	DBT		seq_data;	\/* DBT pointing to seq_record. *\/$/;"	m	struct:__db_sequence
seq_dbp	./include/db.h	/^	DB		*seq_dbp;	\/* DB handle for this sequence. *\/$/;"	m	struct:__db_sequence
seq_key	./include/db.h	/^	DBT		seq_key;	\/* DBT pointing to sequence key. *\/$/;"	m	struct:__db_sequence
seq_last_value	./include/db.h	/^	db_seq_t	seq_last_value;	\/* Last value cached. *\/$/;"	m	struct:__db_sequence
seq_max	./include/db.h	/^	db_seq_t	seq_max;	\/* Max permitted. *\/$/;"	m	struct:__db_seq_record
seq_min	./include/db.h	/^	db_seq_t	seq_min;	\/* Min permitted. *\/$/;"	m	struct:__db_seq_record
seq_prev_value	./include/db.h	/^	db_seq_t	seq_prev_value;	\/* Last value returned. *\/$/;"	m	struct:__db_sequence
seq_record	./include/db.h	/^	DB_SEQ_RECORD	seq_record;	\/* Data from DB_SEQUENCE. *\/$/;"	m	struct:__db_sequence
seq_rp	./include/db.h	/^	DB_SEQ_RECORD	*seq_rp;	\/* Pointer to current data. *\/$/;"	m	struct:__db_sequence
seq_value	./include/db.h	/^	db_seq_t	seq_value;	\/* Current value. *\/$/;"	m	struct:__db_seq_record
seq_version	./include/db.h	/^	u_int32_t	seq_version;	\/* Version size\/number. *\/$/;"	m	struct:__db_seq_record
set_alloc	./include/db.h	/^	int  (*set_alloc) __P((DB *, void *(*)(size_t),$/;"	m	struct:__db
set_alloc	./include/db.h	/^	int  (*set_alloc) __P((DB_ENV *, void *(*)(size_t),$/;"	m	struct:__db_env
set_app_dispatch	./include/db.h	/^	int  (*set_app_dispatch)$/;"	m	struct:__db_env
set_append_recno	./include/db.h	/^	int  (*set_append_recno) __P((DB *, int (*)(DB *, DBT *, db_recno_t)));$/;"	m	struct:__db
set_backup_callbacks	./include/db.h	/^	int  (*set_backup_callbacks) __P((DB_ENV *,$/;"	m	struct:__db_env
set_backup_config	./include/db.h	/^	int  (*set_backup_config) __P((DB_ENV *, DB_BACKUP_CONFIG, u_int32_t));$/;"	m	struct:__db_env
set_blob_dir	./include/db.h	/^	int  (*set_blob_dir) __P((DB *, const char *));$/;"	m	struct:__db
set_blob_dir	./include/db.h	/^	int  (*set_blob_dir) __P((DB_ENV *, const char *));$/;"	m	struct:__db_env
set_blob_threshold	./include/db.h	/^	int  (*set_blob_threshold) __P((DB *, u_int32_t, u_int32_t));$/;"	m	struct:__db
set_blob_threshold	./include/db.h	/^	int  (*set_blob_threshold) __P((DB_ENV *, u_int32_t, u_int32_t));$/;"	m	struct:__db_env
set_bt_compare	./include/db.h	/^	int  (*set_bt_compare)$/;"	m	struct:__db
set_bt_compress	./include/db.h	/^	int  (*set_bt_compress) __P((DB *,$/;"	m	struct:__db
set_bt_minkey	./include/db.h	/^	int  (*set_bt_minkey) __P((DB *, u_int32_t));$/;"	m	struct:__db
set_bt_prefix	./include/db.h	/^	int  (*set_bt_prefix)$/;"	m	struct:__db
set_cache_max	./include/db.h	/^	int  (*set_cache_max) __P((DB_ENV *, u_int32_t, u_int32_t));$/;"	m	struct:__db_env
set_cachesize	./include/db.h	/^	int		(*set_cachesize) __P((DB_SEQUENCE *, u_int32_t));$/;"	m	struct:__db_sequence
set_cachesize	./include/db.h	/^	int  (*set_cachesize) __P((DB *, u_int32_t, u_int32_t, int));$/;"	m	struct:__db
set_cachesize	./include/db.h	/^	int  (*set_cachesize) __P((DB_ENV *, u_int32_t, u_int32_t, int));$/;"	m	struct:__db_env
set_clear_len	./include/db.h	/^	int (*set_clear_len) __P((DB_MPOOLFILE *, u_int32_t));$/;"	m	struct:__db_mpoolfile
set_commit_token	./include/db.h	/^	int	  (*set_commit_token) __P((DB_TXN *, DB_TXN_TOKEN *));$/;"	m	struct:__db_txn
set_config	./include/db.h	/^	int (*set_config) __P((DB_SITE *, u_int32_t, u_int32_t));$/;"	m	struct:__db_site
set_create_dir	./include/db.h	/^	int  (*set_create_dir) __P((DB *, const char *));$/;"	m	struct:__db
set_create_dir	./include/db.h	/^	int  (*set_create_dir) __P((DB_ENV *, const char *));$/;"	m	struct:__db_env
set_data_dir	./include/db.h	/^	int  (*set_data_dir) __P((DB_ENV *, const char *));$/;"	m	struct:__db_env
set_data_len	./include/db.h	/^	int  (*set_data_len) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_dup_compare	./include/db.h	/^	int  (*set_dup_compare)$/;"	m	struct:__db
set_encrypt	./include/db.h	/^	int  (*set_encrypt) __P((DB *, const char *, u_int32_t));$/;"	m	struct:__db
set_encrypt	./include/db.h	/^	int  (*set_encrypt) __P((DB_ENV *, const char *, u_int32_t));$/;"	m	struct:__db_env
set_errcall	./include/db.h	/^	void (*set_errcall) __P((DB *,$/;"	m	struct:__db
set_errcall	./include/db.h	/^	void (*set_errcall) __P((DB_ENV *,$/;"	m	struct:__db_env
set_errfile	./include/db.h	/^	void (*set_errfile) __P((DB *, FILE *));$/;"	m	struct:__db
set_errfile	./include/db.h	/^	void (*set_errfile) __P((DB_ENV *, FILE *));$/;"	m	struct:__db_env
set_errpfx	./include/db.h	/^	void (*set_errpfx) __P((DB *, const char *));$/;"	m	struct:__db
set_errpfx	./include/db.h	/^	void (*set_errpfx) __P((DB_ENV *, const char *));$/;"	m	struct:__db_env
set_event_notify	./include/db.h	/^	int  (*set_event_notify)$/;"	m	struct:__db_env
set_feedback	./include/db.h	/^	int  (*set_feedback) __P((DB *, void (*)(DB *, int, int)));$/;"	m	struct:__db
set_feedback	./include/db.h	/^	int  (*set_feedback) __P((DB_ENV *, void (*)(DB_ENV *, int, int)));$/;"	m	struct:__db_env
set_fileid	./include/db.h	/^	int (*set_fileid) __P((DB_MPOOLFILE *, u_int8_t *));$/;"	m	struct:__db_mpoolfile
set_flags	./include/db.h	/^	int		(*set_flags) __P((DB_SEQUENCE *, u_int32_t));$/;"	m	struct:__db_sequence
set_flags	./include/db.h	/^	int  (*set_flags) __P((DB *, u_int32_t));$/;"	m	struct:__db
set_flags	./include/db.h	/^	int  (*set_flags) __P((DB_ENV *, u_int32_t, int));$/;"	m	struct:__db_env
set_flags	./include/db.h	/^	int (*set_flags) __P((DB_MPOOLFILE *, u_int32_t, int));$/;"	m	struct:__db_mpoolfile
set_ftype	./include/db.h	/^	int (*set_ftype) __P((DB_MPOOLFILE *, int));$/;"	m	struct:__db_mpoolfile
set_h_compare	./include/db.h	/^	int  (*set_h_compare)$/;"	m	struct:__db
set_h_ffactor	./include/db.h	/^	int  (*set_h_ffactor) __P((DB *, u_int32_t));$/;"	m	struct:__db
set_h_hash	./include/db.h	/^	int  (*set_h_hash)$/;"	m	struct:__db
set_h_nelem	./include/db.h	/^	int  (*set_h_nelem) __P((DB *, u_int32_t));$/;"	m	struct:__db
set_heap_regionsize	./include/db.h	/^	int  (*set_heap_regionsize) __P((DB *, u_int32_t));$/;"	m	struct:__db
set_heapsize	./include/db.h	/^	int  (*set_heapsize) __P((DB *, u_int32_t, u_int32_t, u_int32_t));$/;"	m	struct:__db
set_intermediate_dir_mode	./include/db.h	/^	int  (*set_intermediate_dir_mode) __P((DB_ENV *, const char *));$/;"	m	struct:__db_env
set_isalive	./include/db.h	/^	int  (*set_isalive) __P((DB_ENV *,$/;"	m	struct:__db_env
set_lg_bsize	./include/db.h	/^	int  (*set_lg_bsize) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_lg_dir	./include/db.h	/^	int  (*set_lg_dir) __P((DB_ENV *, const char *));$/;"	m	struct:__db_env
set_lg_filemode	./include/db.h	/^	int  (*set_lg_filemode) __P((DB_ENV *, int));$/;"	m	struct:__db_env
set_lg_max	./include/db.h	/^	int  (*set_lg_max) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_lg_regionmax	./include/db.h	/^	int  (*set_lg_regionmax) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_lk_conflicts	./include/db.h	/^	int  (*set_lk_conflicts) __P((DB_ENV *, u_int8_t *, int));$/;"	m	struct:__db_env
set_lk_detect	./include/db.h	/^	int  (*set_lk_detect) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_lk_exclusive	./include/db.h	/^	int  (*set_lk_exclusive) __P((DB *, int));$/;"	m	struct:__db
set_lk_max_lockers	./include/db.h	/^	int  (*set_lk_max_lockers) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_lk_max_locks	./include/db.h	/^	int  (*set_lk_max_locks) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_lk_max_objects	./include/db.h	/^	int  (*set_lk_max_objects) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_lk_partitions	./include/db.h	/^	int  (*set_lk_partitions) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_lk_priority	./include/db.h	/^	int  (*set_lk_priority) __P((DB_ENV *, u_int32_t, u_int32_t));$/;"	m	struct:__db_env
set_lk_tablesize	./include/db.h	/^	int  (*set_lk_tablesize) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_lorder	./include/db.h	/^	int  (*set_lorder) __P((DB *, int));$/;"	m	struct:__db
set_lsn_offset	./include/db.h	/^	int (*set_lsn_offset) __P((DB_MPOOLFILE *, int32_t));$/;"	m	struct:__db_mpoolfile
set_maxsize	./include/db.h	/^	int (*set_maxsize) __P((DB_MPOOLFILE *, u_int32_t, u_int32_t));$/;"	m	struct:__db_mpoolfile
set_memory_init	./include/db.h	/^	int  (*set_memory_init) __P((DB_ENV *, DB_MEM_CONFIG, u_int32_t));$/;"	m	struct:__db_env
set_memory_max	./include/db.h	/^	int  (*set_memory_max) __P((DB_ENV *, u_int32_t, u_int32_t));$/;"	m	struct:__db_env
set_metadata_dir	./include/db.h	/^	int  (*set_metadata_dir) __P((DB_ENV *, const char *));$/;"	m	struct:__db_env
set_mp_max_openfd	./include/db.h	/^	int  (*set_mp_max_openfd) __P((DB_ENV *, int));$/;"	m	struct:__db_env
set_mp_max_write	./include/db.h	/^	int  (*set_mp_max_write) __P((DB_ENV *, int, db_timeout_t));$/;"	m	struct:__db_env
set_mp_mmapsize	./include/db.h	/^	int  (*set_mp_mmapsize) __P((DB_ENV *, size_t));$/;"	m	struct:__db_env
set_mp_mtxcount	./include/db.h	/^	int  (*set_mp_mtxcount) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_mp_pagesize	./include/db.h	/^	int  (*set_mp_pagesize) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_mp_tablesize	./include/db.h	/^	int  (*set_mp_tablesize) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_msgcall	./include/db.h	/^	void (*set_msgcall) __P((DB *, void (*)(const DB_ENV *, const char *)));$/;"	m	struct:__db
set_msgcall	./include/db.h	/^	void (*set_msgcall)$/;"	m	struct:__db_env
set_msgfile	./include/db.h	/^	void (*set_msgfile) __P((DB *, FILE *));$/;"	m	struct:__db
set_msgfile	./include/db.h	/^	void (*set_msgfile) __P((DB_ENV *, FILE *));$/;"	m	struct:__db_env
set_name	./include/db.h	/^	int	  (*set_name) __P((DB_TXN *, const char *));$/;"	m	struct:__db_txn
set_pagesize	./include/db.h	/^	int  (*set_pagesize) __P((DB *, u_int32_t));$/;"	m	struct:__db
set_paniccall	./include/db.h	/^	int  (*set_paniccall) __P((DB *, void (*)(DB_ENV *, int)));$/;"	m	struct:__db
set_paniccall	./include/db.h	/^	int  (*set_paniccall) __P((DB_ENV *, void (*)(DB_ENV *, int)));$/;"	m	struct:__db_env
set_partition	./include/db.h	/^	int  (*set_partition) __P((DB *,$/;"	m	struct:__db
set_partition_dirs	./include/db.h	/^	int  (*set_partition_dirs) __P((DB *, const char **));$/;"	m	struct:__db
set_pgcookie	./include/db.h	/^	int (*set_pgcookie) __P((DB_MPOOLFILE *, DBT *));$/;"	m	struct:__db_mpoolfile
set_priority	./include/db.h	/^	int	  (*set_priority) __P((DB_TXN *, u_int32_t));$/;"	m	struct:__db_txn
set_priority	./include/db.h	/^	int  (*set_priority) __P((DB *, DB_CACHE_PRIORITY));$/;"	m	struct:__db
set_priority	./include/db.h	/^	int (*set_priority) __P((DBC *, DB_CACHE_PRIORITY));$/;"	m	struct:__dbc
set_priority	./include/db.h	/^	int (*set_priority) __P((DB_MPOOLFILE *, DB_CACHE_PRIORITY));$/;"	m	struct:__db_mpoolfile
set_q_extentsize	./include/db.h	/^	int  (*set_q_extentsize) __P((DB *, u_int32_t));$/;"	m	struct:__db
set_range	./include/db.h	/^	int		(*set_range) __P((DB_SEQUENCE *, db_seq_t, db_seq_t));$/;"	m	struct:__db_sequence
set_re_delim	./include/db.h	/^	int  (*set_re_delim) __P((DB *, int));$/;"	m	struct:__db
set_re_len	./include/db.h	/^	int  (*set_re_len) __P((DB *, u_int32_t));$/;"	m	struct:__db
set_re_pad	./include/db.h	/^	int  (*set_re_pad) __P((DB *, int));$/;"	m	struct:__db
set_re_source	./include/db.h	/^	int  (*set_re_source) __P((DB *, const char *));$/;"	m	struct:__db
set_shm_key	./include/db.h	/^	int  (*set_shm_key) __P((DB_ENV *, long));$/;"	m	struct:__db_env
set_thread_count	./include/db.h	/^	int  (*set_thread_count) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_thread_id	./include/db.h	/^	int  (*set_thread_id)$/;"	m	struct:__db_env
set_thread_id_string	./include/db.h	/^	int  (*set_thread_id_string) __P((DB_ENV *,$/;"	m	struct:__db_env
set_timeout	./include/db.h	/^	int	  (*set_timeout) __P((DB_TXN *, db_timeout_t, u_int32_t));$/;"	m	struct:__db_txn
set_timeout	./include/db.h	/^	int  (*set_timeout) __P((DB_CHANNEL *, db_timeout_t));$/;"	m	struct:__db_channel
set_timeout	./include/db.h	/^	int  (*set_timeout) __P((DB_ENV *, db_timeout_t, u_int32_t));$/;"	m	struct:__db_env
set_tmp_dir	./include/db.h	/^	int  (*set_tmp_dir) __P((DB_ENV *, const char *));$/;"	m	struct:__db_env
set_tx_max	./include/db.h	/^	int  (*set_tx_max) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
set_tx_timestamp	./include/db.h	/^	int  (*set_tx_timestamp) __P((DB_ENV *, time_t *));$/;"	m	struct:__db_env
set_txn_lsnp	./include/db.h	/^	void	  (*set_txn_lsnp) __P((DB_TXN *txn, DB_LSN **, DB_LSN **));$/;"	m	struct:__db_txn
set_verbose	./include/db.h	/^	int  (*set_verbose) __P((DB_ENV *, u_int32_t, int));$/;"	m	struct:__db_env
shm_key	./include/db.h	/^	long	 shm_key;		\/* shmget key *\/$/;"	m	struct:__db_env
size	./carray.c	/^	int size;$/;"	m	struct:carray	file:
size	./include/db.h	/^	int  (*size) __P((DB_STREAM *, db_off_t *, u_int32_t));$/;"	m	struct:__db_stream
size	./include/db.h	/^	u_int32_t size;			\/* key\/data length *\/$/;"	m	struct:__db_dbt
sort_multiple	./include/db.h	/^	int  (*sort_multiple) __P((DB *, DBT *, DBT *, u_int32_t));$/;"	m	struct:__db
st_alloc	./include/db.h	/^	uintmax_t st_alloc;		\/* Number of page allocations. *\/$/;"	m	struct:__db_mpool_stat
st_alloc_buckets	./include/db.h	/^	uintmax_t st_alloc_buckets;	\/* Buckets checked during allocation. *\/$/;"	m	struct:__db_mpool_stat
st_alloc_max_buckets	./include/db.h	/^	uintmax_t st_alloc_max_buckets;\/* Max checked during allocation. *\/$/;"	m	struct:__db_mpool_stat
st_alloc_max_pages	./include/db.h	/^	uintmax_t st_alloc_max_pages;	\/* Max checked during allocation. *\/$/;"	m	struct:__db_mpool_stat
st_alloc_pages	./include/db.h	/^	uintmax_t st_alloc_pages;	\/* Pages checked during allocation. *\/$/;"	m	struct:__db_mpool_stat
st_backup_spins	./include/db.h	/^	uintmax_t st_backup_spins;	\/* Number of spins during a copy. *\/$/;"	m	struct:__db_mpool_fstat
st_bulk_fills	./include/db.h	/^	uintmax_t st_bulk_fills;	\/* Bulk buffer fills. *\/$/;"	m	struct:__db_rep_stat
st_bulk_overflows	./include/db.h	/^	uintmax_t st_bulk_overflows;	\/* Bulk buffer overflows. *\/$/;"	m	struct:__db_rep_stat
st_bulk_records	./include/db.h	/^	uintmax_t st_bulk_records;	\/* Bulk records stored. *\/$/;"	m	struct:__db_rep_stat
st_bulk_transfers	./include/db.h	/^	uintmax_t st_bulk_transfers;	\/* Transfers of bulk buffers. *\/$/;"	m	struct:__db_rep_stat
st_bytes	./include/db.h	/^	u_int32_t st_bytes;		\/* Total cache size: B. *\/$/;"	m	struct:__db_mpool_stat
st_cache_hit	./include/db.h	/^	uintmax_t st_cache_hit;	\/* Pages found in the cache. *\/$/;"	m	struct:__db_mpool_fstat
st_cache_hit	./include/db.h	/^	uintmax_t st_cache_hit;	\/* Pages found in the cache. *\/$/;"	m	struct:__db_mpool_stat
st_cache_miss	./include/db.h	/^	uintmax_t st_cache_miss;	\/* Pages not found in the cache. *\/$/;"	m	struct:__db_mpool_fstat
st_cache_miss	./include/db.h	/^	uintmax_t st_cache_miss;	\/* Pages not found in the cache. *\/$/;"	m	struct:__db_mpool_stat
st_cache_size	./include/db.h	/^	u_int32_t st_cache_size;	\/* Cache size. *\/$/;"	m	struct:__db_seq_stat
st_client_rerequests	./include/db.h	/^	uintmax_t st_client_rerequests;\/* Number of forced rerequests. *\/$/;"	m	struct:__db_rep_stat
st_client_svc_miss	./include/db.h	/^	uintmax_t st_client_svc_miss;	\/* Number of client service requests$/;"	m	struct:__db_rep_stat
st_client_svc_req	./include/db.h	/^	uintmax_t st_client_svc_req;	\/* Number of client service requests$/;"	m	struct:__db_rep_stat
st_connect_fail	./include/db.h	/^	uintmax_t st_connect_fail;	\/* Failed new connection attempts. *\/$/;"	m	struct:__db_repmgr_stat
st_connection_drop	./include/db.h	/^	uintmax_t st_connection_drop;	\/* Existing connections dropped. *\/$/;"	m	struct:__db_repmgr_stat
st_cur_file	./include/db.h	/^	u_int32_t st_cur_file;		\/* Current log file number. *\/$/;"	m	struct:__db_log_stat
st_cur_maxid	./include/db.h	/^	u_int32_t st_cur_maxid;		\/* Current maximum unused ID. *\/$/;"	m	struct:__db_lock_stat
st_cur_offset	./include/db.h	/^	u_int32_t st_cur_offset;	\/* Current log file offset. *\/$/;"	m	struct:__db_log_stat
st_current	./include/db.h	/^	db_seq_t  st_current;		\/* Current value in db. *\/$/;"	m	struct:__db_seq_stat
st_disk_file	./include/db.h	/^	u_int32_t st_disk_file;		\/* Known on disk log file number. *\/$/;"	m	struct:__db_log_stat
st_disk_offset	./include/db.h	/^	u_int32_t st_disk_offset;	\/* Known on disk log file offset. *\/$/;"	m	struct:__db_log_stat
st_dupmasters	./include/db.h	/^	u_int32_t st_dupmasters;	\/* # of times a duplicate master$/;"	m	struct:__db_rep_stat
st_egen	./include/db.h	/^	u_int32_t st_egen;		\/* Current election gen number. *\/$/;"	m	struct:__db_rep_stat
st_elect_threads	./include/db.h	/^	u_int32_t st_elect_threads;	\/* # of active election threads. *\/$/;"	m	struct:__db_repmgr_stat
st_election_cur_winner	./include/db.h	/^	db_ssize_t st_election_cur_winner;	\/* Current front-runner. *\/$/;"	m	struct:__db_rep_stat
st_election_datagen	./include/db.h	/^	u_int32_t st_election_datagen;	\/* Election data generation number. *\/$/;"	m	struct:__db_rep_stat
st_election_gen	./include/db.h	/^	u_int32_t st_election_gen;	\/* Election generation number. *\/$/;"	m	struct:__db_rep_stat
st_election_lsn	./include/db.h	/^	DB_LSN st_election_lsn;		\/* Max. LSN of current winner. *\/$/;"	m	struct:__db_rep_stat
st_election_nsites	./include/db.h	/^	u_int32_t st_election_nsites;	\/* # of "registered voters". *\/$/;"	m	struct:__db_rep_stat
st_election_nvotes	./include/db.h	/^	u_int32_t st_election_nvotes;	\/* # of "registered voters" needed. *\/$/;"	m	struct:__db_rep_stat
st_election_priority	./include/db.h	/^	u_int32_t st_election_priority;	\/* Current election priority. *\/$/;"	m	struct:__db_rep_stat
st_election_sec	./include/db.h	/^	u_int32_t st_election_sec;	\/* Last election time seconds. *\/$/;"	m	struct:__db_rep_stat
st_election_status	./include/db.h	/^	int32_t   st_election_status;	\/* Current election status. *\/$/;"	m	struct:__db_rep_stat
st_election_tiebreaker	./include/db.h	/^	u_int32_t st_election_tiebreaker;\/* Election tiebreaker value. *\/$/;"	m	struct:__db_rep_stat
st_election_usec	./include/db.h	/^	u_int32_t st_election_usec;	\/* Last election time useconds. *\/$/;"	m	struct:__db_rep_stat
st_election_votes	./include/db.h	/^	u_int32_t st_election_votes;	\/* Votes received in this round. *\/$/;"	m	struct:__db_rep_stat
st_elections	./include/db.h	/^	uintmax_t st_elections;	\/* # of elections held.+ *\/$/;"	m	struct:__db_rep_stat
st_elections_won	./include/db.h	/^	uintmax_t st_elections_won;	\/* # of elections won by this site.+ *\/$/;"	m	struct:__db_rep_stat
st_env_id	./include/db.h	/^	db_ssize_t st_env_id;		\/* Current environment ID. *\/$/;"	m	struct:__db_rep_stat
st_env_priority	./include/db.h	/^	u_int32_t st_env_priority;	\/* Current environment priority. *\/$/;"	m	struct:__db_rep_stat
st_filefail_cleanups	./include/db.h	/^	u_int32_t st_filefail_cleanups;	\/* # of FILE_FAIL cleanups done. *\/$/;"	m	struct:__db_rep_stat
st_fileid_init	./include/db.h	/^	u_int32_t st_fileid_init;	\/* Initial allocation for fileids. *\/$/;"	m	struct:__db_log_stat
st_flags	./include/db.h	/^	u_int32_t st_flags;		\/* Flag value. *\/$/;"	m	struct:__db_seq_stat
st_gbytes	./include/db.h	/^	u_int32_t st_gbytes;		\/* Total cache size: GB. *\/$/;"	m	struct:__db_mpool_stat
st_gen	./include/db.h	/^	u_int32_t st_gen;		\/* Current generation number. *\/$/;"	m	struct:__db_rep_stat
st_hash_buckets	./include/db.h	/^	u_int32_t st_hash_buckets;	\/* Number of hash buckets. *\/$/;"	m	struct:__db_mpool_stat
st_hash_examined	./include/db.h	/^	uintmax_t st_hash_examined;	\/* Total hash entries searched. *\/$/;"	m	struct:__db_mpool_stat
st_hash_len	./include/db.h	/^	u_int32_t st_hash_len;		\/* Max length of bucket. *\/$/;"	m	struct:__db_lock_hstat
st_hash_len	./include/db.h	/^	u_int32_t st_hash_len;		\/* Max length of bucket. *\/$/;"	m	struct:__db_lock_stat
st_hash_longest	./include/db.h	/^	u_int32_t st_hash_longest;	\/* Longest hash chain searched. *\/$/;"	m	struct:__db_mpool_stat
st_hash_max_nowait	./include/db.h	/^	uintmax_t st_hash_max_nowait;	\/* Max hash lock granted with nowait. *\/$/;"	m	struct:__db_mpool_stat
st_hash_max_wait	./include/db.h	/^	uintmax_t st_hash_max_wait;	\/* Max hash lock granted after wait. *\/$/;"	m	struct:__db_mpool_stat
st_hash_mutexes	./include/db.h	/^	u_int32_t st_hash_mutexes;	\/* Number of hash bucket mutexes. *\/$/;"	m	struct:__db_mpool_stat
st_hash_nowait	./include/db.h	/^	uintmax_t st_hash_nowait;	\/* Hash lock granted with nowait. *\/$/;"	m	struct:__db_mpool_stat
st_hash_searches	./include/db.h	/^	u_int32_t st_hash_searches;	\/* Total hash chain searches. *\/$/;"	m	struct:__db_mpool_stat
st_hash_wait	./include/db.h	/^	uintmax_t st_hash_wait;		\/* Hash lock granted after wait. *\/$/;"	m	struct:__db_mpool_stat
st_id	./include/db.h	/^	u_int32_t st_id;		\/* Last allocated locker ID. *\/$/;"	m	struct:__db_lock_stat
st_incoming_queue_size	./include/db.h	/^	u_int32_t st_incoming_queue_size; \/* Undoc: # msgs currently queued. *\/$/;"	m	struct:__db_repmgr_stat
st_initlockers	./include/db.h	/^	u_int32_t st_initlockers;	\/* Initial num of lockers in table. *\/$/;"	m	struct:__db_lock_stat
st_initlocks	./include/db.h	/^	u_int32_t st_initlocks;		\/* Initial number of locks in table. *\/$/;"	m	struct:__db_lock_stat
st_initobjects	./include/db.h	/^	u_int32_t st_initobjects;	\/* Initial num of objects in table. *\/$/;"	m	struct:__db_lock_stat
st_inittxns	./include/db.h	/^	u_int32_t st_inittxns;		\/* inital txns allocated *\/$/;"	m	struct:__db_txn_stat
st_io_wait	./include/db.h	/^	uintmax_t st_io_wait;		\/* Thread waited on buffer I\/O. *\/$/;"	m	struct:__db_mpool_stat
st_last_ckp	./include/db.h	/^	DB_LSN	  st_last_ckp;		\/* lsn of the last checkpoint *\/$/;"	m	struct:__db_txn_stat
st_last_txnid	./include/db.h	/^	u_int32_t st_last_txnid;	\/* last transaction id given out *\/$/;"	m	struct:__db_txn_stat
st_last_value	./include/db.h	/^	db_seq_t  st_last_value;	\/* Last cached value. *\/$/;"	m	struct:__db_seq_stat
st_lease_chk	./include/db.h	/^	uintmax_t st_lease_chk;		\/* Lease validity checks. *\/$/;"	m	struct:__db_rep_stat
st_lease_chk_misses	./include/db.h	/^	uintmax_t st_lease_chk_misses;	\/* Lease checks invalid. *\/$/;"	m	struct:__db_rep_stat
st_lease_chk_refresh	./include/db.h	/^	uintmax_t st_lease_chk_refresh;	\/* Lease refresh attempts. *\/$/;"	m	struct:__db_rep_stat
st_lease_sends	./include/db.h	/^	uintmax_t st_lease_sends;	\/* Lease messages sent live. *\/$/;"	m	struct:__db_rep_stat
st_lg_bsize	./include/db.h	/^	u_int32_t st_lg_bsize;		\/* Log buffer size. *\/$/;"	m	struct:__db_log_stat
st_lg_size	./include/db.h	/^	u_int32_t st_lg_size;		\/* Log file size. *\/$/;"	m	struct:__db_log_stat
st_lock_nowait	./include/db.h	/^	uintmax_t st_lock_nowait;	\/* Lock conflicts w\/o subsequent wait *\/$/;"	m	struct:__db_lock_hstat
st_lock_nowait	./include/db.h	/^	uintmax_t st_lock_nowait;	\/* Lock conflicts w\/o subsequent wait *\/$/;"	m	struct:__db_lock_stat
st_lock_wait	./include/db.h	/^	uintmax_t st_lock_wait;		\/* Lock conflicts w\/ subsequent wait *\/$/;"	m	struct:__db_lock_hstat
st_lock_wait	./include/db.h	/^	uintmax_t st_lock_wait;		\/* Lock conflicts w\/ subsequent wait *\/$/;"	m	struct:__db_lock_stat
st_lockers	./include/db.h	/^	u_int32_t st_lockers;		\/* Current num of lockers in table. *\/$/;"	m	struct:__db_lock_stat
st_lockers_nowait	./include/db.h	/^	uintmax_t st_lockers_nowait;	\/* Locker lock granted without wait. *\/$/;"	m	struct:__db_lock_stat
st_lockers_wait	./include/db.h	/^	uintmax_t st_lockers_wait;	\/* Locker lock granted after wait. *\/$/;"	m	struct:__db_lock_stat
st_locks	./include/db.h	/^	u_int32_t st_locks;		\/* Current number of locks in table. *\/$/;"	m	struct:__db_lock_stat
st_locksteals	./include/db.h	/^	uintmax_t st_locksteals;	\/* Number of lock steals so far. *\/$/;"	m	struct:__db_lock_pstat
st_locksteals	./include/db.h	/^	uintmax_t st_locksteals;	\/* Number of lock steals so far. *\/$/;"	m	struct:__db_lock_stat
st_locktimeout	./include/db.h	/^	db_timeout_t st_locktimeout;	\/* Lock timeout. *\/$/;"	m	struct:__db_lock_stat
st_log_duplicated	./include/db.h	/^	uintmax_t st_log_duplicated;	\/* Log records received multiply.+ *\/$/;"	m	struct:__db_rep_stat
st_log_futuredup	./include/db.h	/^	uintmax_t st_log_futuredup;	\/* Future log records that are dups. *\/$/;"	m	struct:__db_rep_stat
st_log_queued	./include/db.h	/^	uintmax_t st_log_queued;	\/* Log records currently queued.+ *\/$/;"	m	struct:__db_rep_stat
st_log_queued_max	./include/db.h	/^	uintmax_t st_log_queued_max;	\/* Max. log records queued at once.+ *\/$/;"	m	struct:__db_rep_stat
st_log_queued_total	./include/db.h	/^	uintmax_t st_log_queued_total;	\/* Total # of log recs. ever queued.+ *\/$/;"	m	struct:__db_rep_stat
st_log_records	./include/db.h	/^	uintmax_t st_log_records;	\/* Log records received and put.+ *\/$/;"	m	struct:__db_rep_stat
st_log_requested	./include/db.h	/^	uintmax_t st_log_requested;	\/* Log recs. missed and requested.+ *\/$/;"	m	struct:__db_rep_stat
st_magic	./include/db.h	/^	u_int32_t st_magic;		\/* Log file magic number. *\/$/;"	m	struct:__db_log_stat
st_map	./include/db.h	/^	u_int32_t st_map;		\/* Pages from mapped files. *\/$/;"	m	struct:__db_mpool_fstat
st_map	./include/db.h	/^	u_int32_t st_map;		\/* Pages from mapped files. *\/$/;"	m	struct:__db_mpool_stat
st_master	./include/db.h	/^	db_ssize_t st_master;		\/* Env. ID of the current master. *\/$/;"	m	struct:__db_rep_stat
st_master_changes	./include/db.h	/^	uintmax_t st_master_changes;	\/* # of times we've switched masters. *\/$/;"	m	struct:__db_rep_stat
st_max	./include/db.h	/^	db_seq_t  st_max;		\/* Maximum value. *\/$/;"	m	struct:__db_seq_stat
st_max_elect_threads	./include/db.h	/^	u_int32_t st_max_elect_threads;	\/* Max concurrent e-threads ever. *\/$/;"	m	struct:__db_repmgr_stat
st_max_lease_sec	./include/db.h	/^	u_int32_t st_max_lease_sec;	\/* Maximum lease timestamp seconds. *\/$/;"	m	struct:__db_rep_stat
st_max_lease_usec	./include/db.h	/^	u_int32_t st_max_lease_usec;	\/* Maximum lease timestamp useconds. *\/$/;"	m	struct:__db_rep_stat
st_max_ncache	./include/db.h	/^	u_int32_t st_max_ncache;	\/* Maximum number of regions. *\/$/;"	m	struct:__db_mpool_stat
st_max_perm_lsn	./include/db.h	/^	DB_LSN st_max_perm_lsn;		\/* Maximum permanent LSN. *\/$/;"	m	struct:__db_rep_stat
st_maxcommitperflush	./include/db.h	/^	u_int32_t st_maxcommitperflush;	\/* Max number of commits in a flush. *\/$/;"	m	struct:__db_log_stat
st_maxhlocks	./include/db.h	/^	u_int32_t st_maxhlocks;		\/* Maximum number of locks in any bucket. *\/$/;"	m	struct:__db_lock_stat
st_maxhobjects	./include/db.h	/^	u_int32_t st_maxhobjects;	\/* Maximum number of objectsin any bucket. *\/$/;"	m	struct:__db_lock_stat
st_maxlockers	./include/db.h	/^	u_int32_t st_maxlockers;	\/* Maximum num of lockers in table. *\/$/;"	m	struct:__db_lock_stat
st_maxlocks	./include/db.h	/^	u_int32_t st_maxlocks;		\/* Maximum number of locks in table. *\/$/;"	m	struct:__db_lock_stat
st_maxlsteals	./include/db.h	/^	uintmax_t st_maxlsteals;	\/* Maximum number steals in any partition. *\/$/;"	m	struct:__db_lock_stat
st_maxnactive	./include/db.h	/^	u_int32_t st_maxnactive;	\/* maximum active transactions *\/$/;"	m	struct:__db_txn_stat
st_maxnfileid	./include/db.h	/^	u_int32_t st_maxnfileid;	\/* Maximum number of fileids used. *\/$/;"	m	struct:__db_log_stat
st_maxnlockers	./include/db.h	/^	u_int32_t st_maxnlockers;	\/* Maximum number of lockers so far. *\/$/;"	m	struct:__db_lock_stat
st_maxnlocks	./include/db.h	/^	u_int32_t st_maxnlocks;		\/* Maximum number of locks so far. *\/$/;"	m	struct:__db_lock_hstat
st_maxnlocks	./include/db.h	/^	u_int32_t st_maxnlocks;		\/* Maximum number of locks so far. *\/$/;"	m	struct:__db_lock_pstat
st_maxnlocks	./include/db.h	/^	u_int32_t st_maxnlocks;		\/* Maximum number of locks so far. *\/$/;"	m	struct:__db_lock_stat
st_maxnobjects	./include/db.h	/^	u_int32_t st_maxnobjects;	\/* Maximum number of objects so far. *\/$/;"	m	struct:__db_lock_hstat
st_maxnobjects	./include/db.h	/^	u_int32_t st_maxnobjects;	\/* Maximum number of objects so far. *\/$/;"	m	struct:__db_lock_pstat
st_maxnobjects	./include/db.h	/^	u_int32_t st_maxnobjects;	\/* Maximum number of objects so far. *\/$/;"	m	struct:__db_lock_stat
st_maxnsnapshot	./include/db.h	/^	u_int32_t st_maxnsnapshot;	\/* maximum snapshot transactions *\/$/;"	m	struct:__db_txn_stat
st_maxobjects	./include/db.h	/^	u_int32_t st_maxobjects;	\/* Maximum num of objects in table. *\/$/;"	m	struct:__db_lock_stat
st_maxopenfd	./include/db.h	/^	int32_t st_maxopenfd;		\/* Maximum number of open fd's. *\/$/;"	m	struct:__db_mpool_stat
st_maxosteals	./include/db.h	/^	uintmax_t st_maxosteals;	\/* Maximum number of steals in any partition. *\/$/;"	m	struct:__db_lock_stat
st_maxtxns	./include/db.h	/^	u_int32_t st_maxtxns;		\/* maximum txns possible *\/$/;"	m	struct:__db_txn_stat
st_maxwrite	./include/db.h	/^	int32_t st_maxwrite;		\/* Maximum buffers to write. *\/$/;"	m	struct:__db_mpool_stat
st_maxwrite_sleep	./include/db.h	/^	db_timeout_t st_maxwrite_sleep;	\/* Sleep after writing max buffers. *\/$/;"	m	struct:__db_mpool_stat
st_min	./include/db.h	/^	db_seq_t  st_min;		\/* Minimum value. *\/$/;"	m	struct:__db_seq_stat
st_mincommitperflush	./include/db.h	/^	u_int32_t st_mincommitperflush;	\/* Min number of commits in a flush. *\/$/;"	m	struct:__db_log_stat
st_mmapsize	./include/db.h	/^	db_size_t st_mmapsize;		\/* Maximum file size for mmap. *\/$/;"	m	struct:__db_mpool_stat
st_mode	./include/db.h	/^	int32_t   st_mode;		\/* Log file permissions mode. *\/$/;"	m	struct:__db_log_stat
st_msgs_badgen	./include/db.h	/^	uintmax_t st_msgs_badgen;	\/* Messages with a bad generation #.+ *\/$/;"	m	struct:__db_rep_stat
st_msgs_dropped	./include/db.h	/^	uintmax_t st_msgs_dropped;	\/* # msgs discarded due to excessive$/;"	m	struct:__db_repmgr_stat
st_msgs_processed	./include/db.h	/^	uintmax_t st_msgs_processed;	\/* Messages received and processed.+ *\/$/;"	m	struct:__db_rep_stat
st_msgs_queued	./include/db.h	/^	uintmax_t st_msgs_queued;	\/* # msgs queued for network delay. *\/$/;"	m	struct:__db_repmgr_stat
st_msgs_recover	./include/db.h	/^	uintmax_t st_msgs_recover;	\/* Messages ignored because this site$/;"	m	struct:__db_rep_stat
st_msgs_send_failures	./include/db.h	/^	uintmax_t st_msgs_send_failures;\/* # of failed message sends.+ *\/$/;"	m	struct:__db_rep_stat
st_msgs_sent	./include/db.h	/^	uintmax_t st_msgs_sent;	\/* # of successful message sends.+ *\/$/;"	m	struct:__db_rep_stat
st_mutex_align	./include/db.h	/^	u_int32_t st_mutex_align;	\/* Mutex alignment *\/$/;"	m	struct:__db_mutex_stat
st_mutex_cnt	./include/db.h	/^	u_int32_t st_mutex_cnt;		\/* Mutex count *\/$/;"	m	struct:__db_mutex_stat
st_mutex_free	./include/db.h	/^	u_int32_t st_mutex_free;	\/* Available mutexes *\/$/;"	m	struct:__db_mutex_stat
st_mutex_init	./include/db.h	/^	u_int32_t st_mutex_init;	\/* Initial mutex count *\/$/;"	m	struct:__db_mutex_stat
st_mutex_inuse	./include/db.h	/^	u_int32_t st_mutex_inuse;	\/* Mutexes in use *\/$/;"	m	struct:__db_mutex_stat
st_mutex_inuse_max	./include/db.h	/^	u_int32_t st_mutex_inuse_max;	\/* Maximum mutexes ever in use *\/$/;"	m	struct:__db_mutex_stat
st_mutex_max	./include/db.h	/^	u_int32_t st_mutex_max;		\/* Mutex max *\/$/;"	m	struct:__db_mutex_stat
st_mutex_tas_spins	./include/db.h	/^	u_int32_t st_mutex_tas_spins;	\/* Mutex test-and-set spins *\/$/;"	m	struct:__db_mutex_stat
st_mvcc_freed	./include/db.h	/^	uintmax_t st_mvcc_freed;	\/* Frozen buffers freed. *\/$/;"	m	struct:__db_mpool_stat
st_mvcc_frozen	./include/db.h	/^	uintmax_t st_mvcc_frozen;	\/* Buffers frozen. *\/$/;"	m	struct:__db_mpool_stat
st_mvcc_reused	./include/db.h	/^	uintmax_t st_mvcc_reused;	\/* Outdated invisible buffers reused. *\/$/;"	m	struct:__db_mpool_stat
st_mvcc_thawed	./include/db.h	/^	uintmax_t st_mvcc_thawed;	\/* Buffers thawed. *\/$/;"	m	struct:__db_mpool_stat
st_naborts	./include/db.h	/^	uintmax_t st_naborts;		\/* number of aborted transactions *\/$/;"	m	struct:__db_txn_stat
st_nactive	./include/db.h	/^	u_int32_t st_nactive;		\/* number of active transactions *\/$/;"	m	struct:__db_txn_stat
st_nbegins	./include/db.h	/^	uintmax_t st_nbegins;		\/* number of begun transactions *\/$/;"	m	struct:__db_txn_stat
st_ncache	./include/db.h	/^	u_int32_t st_ncache;		\/* Number of cache regions. *\/$/;"	m	struct:__db_mpool_stat
st_ncommits	./include/db.h	/^	uintmax_t st_ncommits;		\/* number of committed transactions *\/$/;"	m	struct:__db_txn_stat
st_ndeadlocks	./include/db.h	/^	uintmax_t st_ndeadlocks;	\/* Number of lock deadlocks. *\/$/;"	m	struct:__db_lock_stat
st_ndowngrade	./include/db.h	/^	uintmax_t st_ndowngrade;	\/* Number of lock downgrades. *\/$/;"	m	struct:__db_lock_hstat
st_ndowngrade	./include/db.h	/^	uintmax_t st_ndowngrade;	\/* Number of lock downgrades. *\/$/;"	m	struct:__db_lock_stat
st_newsites	./include/db.h	/^	uintmax_t st_newsites;		\/* # of NEWSITE msgs. received.+ *\/$/;"	m	struct:__db_rep_stat
st_next_lsn	./include/db.h	/^	DB_LSN st_next_lsn;		\/* Next LSN to use or expect. *\/$/;"	m	struct:__db_rep_stat
st_next_pg	./include/db.h	/^	db_pgno_t st_next_pg;		\/* Next pg we expect. *\/$/;"	m	struct:__db_rep_stat
st_nfileid	./include/db.h	/^	u_int32_t st_nfileid;		\/* Current number of fileids. *\/$/;"	m	struct:__db_log_stat
st_nlockers	./include/db.h	/^	u_int32_t st_nlockers;		\/* Current number of lockers. *\/$/;"	m	struct:__db_lock_stat
st_nlockers_hit	./include/db.h	/^	uintmax_t st_nlockers_hit;	\/* Lockers found in thread info. *\/$/;"	m	struct:__db_lock_stat
st_nlockers_reused	./include/db.h	/^	uintmax_t st_nlockers_reused;	\/* Lockers reallocated from thread info. *\/$/;"	m	struct:__db_lock_stat
st_nlocks	./include/db.h	/^	u_int32_t st_nlocks;		\/* Current number of locks. *\/$/;"	m	struct:__db_lock_hstat
st_nlocks	./include/db.h	/^	u_int32_t st_nlocks;		\/* Current number of locks. *\/$/;"	m	struct:__db_lock_pstat
st_nlocks	./include/db.h	/^	u_int32_t st_nlocks;		\/* Current number of locks. *\/$/;"	m	struct:__db_lock_stat
st_nlocktimeouts	./include/db.h	/^	uintmax_t st_nlocktimeouts;	\/* Number of lock timeouts. *\/$/;"	m	struct:__db_lock_hstat
st_nlocktimeouts	./include/db.h	/^	uintmax_t st_nlocktimeouts;	\/* Number of lock timeouts. *\/$/;"	m	struct:__db_lock_stat
st_nmodes	./include/db.h	/^	int32_t   st_nmodes;		\/* Number of lock modes. *\/$/;"	m	struct:__db_lock_stat
st_nobjects	./include/db.h	/^	u_int32_t st_nobjects;		\/* Current number of objects. *\/$/;"	m	struct:__db_lock_hstat
st_nobjects	./include/db.h	/^	u_int32_t st_nobjects;		\/* Current number of objects. *\/$/;"	m	struct:__db_lock_pstat
st_nobjects	./include/db.h	/^	u_int32_t st_nobjects;		\/* Current number of objects. *\/$/;"	m	struct:__db_lock_stat
st_nowait	./include/db.h	/^	uintmax_t st_nowait;		\/* Sequence lock granted after wait. *\/$/;"	m	struct:__db_seq_stat
st_nreleases	./include/db.h	/^	uintmax_t st_nreleases;		\/* Number of lock puts. *\/$/;"	m	struct:__db_lock_hstat
st_nreleases	./include/db.h	/^	uintmax_t st_nreleases;		\/* Number of lock puts. *\/$/;"	m	struct:__db_lock_stat
st_nrequests	./include/db.h	/^	uintmax_t st_nrequests;		\/* Number of lock gets. *\/$/;"	m	struct:__db_lock_hstat
st_nrequests	./include/db.h	/^	uintmax_t st_nrequests;		\/* Number of lock gets. *\/$/;"	m	struct:__db_lock_stat
st_nrestores	./include/db.h	/^	u_int32_t st_nrestores;		\/* number of restored transactions$/;"	m	struct:__db_txn_stat
st_nsites	./include/db.h	/^	u_int32_t st_nsites;		\/* Current number of sites we will$/;"	m	struct:__db_rep_stat
st_nsnapshot	./include/db.h	/^	u_int32_t st_nsnapshot;		\/* number of snapshot transactions *\/$/;"	m	struct:__db_txn_stat
st_nthrottles	./include/db.h	/^	uintmax_t st_nthrottles;	\/* # of times we were throttled. *\/$/;"	m	struct:__db_rep_stat
st_ntxntimeouts	./include/db.h	/^	uintmax_t st_ntxntimeouts;	\/* Number of transaction timeouts. *\/$/;"	m	struct:__db_lock_hstat
st_ntxntimeouts	./include/db.h	/^	uintmax_t st_ntxntimeouts;	\/* Number of transaction timeouts. *\/$/;"	m	struct:__db_lock_stat
st_nupgrade	./include/db.h	/^	uintmax_t st_nupgrade;		\/* Number of lock upgrades. *\/$/;"	m	struct:__db_lock_hstat
st_nupgrade	./include/db.h	/^	uintmax_t st_nupgrade;		\/* Number of lock upgrades. *\/$/;"	m	struct:__db_lock_stat
st_objects	./include/db.h	/^	u_int32_t st_objects;		\/* Current num of objects in table. *\/$/;"	m	struct:__db_lock_stat
st_objectsteals	./include/db.h	/^	uintmax_t st_objectsteals;	\/* Number of objects steals so far. *\/$/;"	m	struct:__db_lock_pstat
st_objectsteals	./include/db.h	/^	uintmax_t st_objectsteals;	\/* Number of objects steals so far. *\/$/;"	m	struct:__db_lock_stat
st_objs_nowait	./include/db.h	/^	uintmax_t st_objs_nowait;	\/* Object lock granted without wait. *\/$/;"	m	struct:__db_lock_stat
st_objs_wait	./include/db.h	/^	uintmax_t st_objs_wait;	\/* 	Object lock granted after wait. *\/$/;"	m	struct:__db_lock_stat
st_oddfsize_detect	./include/db.h	/^	u_int32_t st_oddfsize_detect;	\/* Odd file size detected. *\/$/;"	m	struct:__db_mpool_stat
st_oddfsize_resolve	./include/db.h	/^	u_int32_t st_oddfsize_resolve;	\/* Odd file size resolved. *\/$/;"	m	struct:__db_mpool_stat
st_outdated	./include/db.h	/^	uintmax_t st_outdated;		\/* # of times we detected and returned$/;"	m	struct:__db_rep_stat
st_page_clean	./include/db.h	/^	u_int32_t st_page_clean;	\/* Clean pages. *\/$/;"	m	struct:__db_mpool_stat
st_page_create	./include/db.h	/^	uintmax_t st_page_create;	\/* Pages created in the cache. *\/$/;"	m	struct:__db_mpool_fstat
st_page_create	./include/db.h	/^	uintmax_t st_page_create;	\/* Pages created in the cache. *\/$/;"	m	struct:__db_mpool_stat
st_page_dirty	./include/db.h	/^	u_int32_t st_page_dirty;	\/* Dirty pages. *\/$/;"	m	struct:__db_mpool_stat
st_page_in	./include/db.h	/^	uintmax_t st_page_in;		\/* Pages read in. *\/$/;"	m	struct:__db_mpool_fstat
st_page_in	./include/db.h	/^	uintmax_t st_page_in;		\/* Pages read in. *\/$/;"	m	struct:__db_mpool_stat
st_page_out	./include/db.h	/^	uintmax_t st_page_out;		\/* Pages written out. *\/$/;"	m	struct:__db_mpool_fstat
st_page_out	./include/db.h	/^	uintmax_t st_page_out;		\/* Pages written out. *\/$/;"	m	struct:__db_mpool_stat
st_page_trickle	./include/db.h	/^	uintmax_t st_page_trickle;	\/* Pages written by memp_trickle. *\/$/;"	m	struct:__db_mpool_stat
st_pages	./include/db.h	/^	u_int32_t st_pages;		\/* Total number of pages. *\/$/;"	m	struct:__db_mpool_stat
st_pagesize	./include/db.h	/^	u_int32_t st_pagesize;		\/* Assumed page size. *\/$/;"	m	struct:__db_mpool_stat
st_pagesize	./include/db.h	/^	u_int32_t st_pagesize;		\/* Page size. *\/$/;"	m	struct:__db_mpool_fstat
st_part_max_nowait	./include/db.h	/^	uintmax_t st_part_max_nowait;	\/* Max partition lock granted without wait. *\/$/;"	m	struct:__db_lock_stat
st_part_max_wait	./include/db.h	/^	uintmax_t st_part_max_wait;	\/* Max partition lock granted after wait. *\/$/;"	m	struct:__db_lock_stat
st_part_nowait	./include/db.h	/^	uintmax_t st_part_nowait;	\/* Partition lock granted without wait. *\/$/;"	m	struct:__db_lock_stat
st_part_wait	./include/db.h	/^	uintmax_t st_part_wait;		\/* Partition lock granted after wait. *\/$/;"	m	struct:__db_lock_stat
st_partitions	./include/db.h	/^	u_int32_t st_partitions;	\/* number of partitions. *\/$/;"	m	struct:__db_lock_stat
st_perm_failed	./include/db.h	/^	uintmax_t st_perm_failed;	\/* # of insufficiently ack'ed msgs. *\/$/;"	m	struct:__db_repmgr_stat
st_pg_duplicated	./include/db.h	/^	uintmax_t st_pg_duplicated;	\/* Pages received multiply.+ *\/$/;"	m	struct:__db_rep_stat
st_pg_records	./include/db.h	/^	uintmax_t st_pg_records;	\/* Pages received and stored.+ *\/$/;"	m	struct:__db_rep_stat
st_pg_requested	./include/db.h	/^	uintmax_t st_pg_requested;	\/* Pages missed and requested.+ *\/$/;"	m	struct:__db_rep_stat
st_rcount	./include/db.h	/^	uintmax_t st_rcount;		\/* Total I\/O reads from the log. *\/$/;"	m	struct:__db_log_stat
st_record	./include/db.h	/^	uintmax_t st_record;		\/* Records entered into the log. *\/$/;"	m	struct:__db_log_stat
st_region_nowait	./include/db.h	/^	uintmax_t st_region_nowait;	\/* Region lock granted with nowait. *\/$/;"	m	struct:__db_mpool_stat
st_region_nowait	./include/db.h	/^	uintmax_t st_region_nowait;	\/* Region lock granted without wait. *\/$/;"	m	struct:__db_lock_stat
st_region_nowait	./include/db.h	/^	uintmax_t st_region_nowait;	\/* Region lock granted without wait. *\/$/;"	m	struct:__db_log_stat
st_region_nowait	./include/db.h	/^	uintmax_t st_region_nowait;	\/* Region lock granted without wait. *\/$/;"	m	struct:__db_mutex_stat
st_region_nowait	./include/db.h	/^	uintmax_t st_region_nowait;	\/* Region lock granted without wait. *\/$/;"	m	struct:__db_txn_stat
st_region_wait	./include/db.h	/^	uintmax_t st_region_wait;	\/* Region lock granted after wait. *\/$/;"	m	struct:__db_lock_stat
st_region_wait	./include/db.h	/^	uintmax_t st_region_wait;	\/* Region lock granted after wait. *\/$/;"	m	struct:__db_log_stat
st_region_wait	./include/db.h	/^	uintmax_t st_region_wait;	\/* Region lock granted after wait. *\/$/;"	m	struct:__db_mpool_stat
st_region_wait	./include/db.h	/^	uintmax_t st_region_wait;	\/* Region lock granted after wait. *\/$/;"	m	struct:__db_mutex_stat
st_region_wait	./include/db.h	/^	uintmax_t st_region_wait;	\/* Region lock granted after wait. *\/$/;"	m	struct:__db_txn_stat
st_regmax	./include/db.h	/^	roff_t	  st_regmax;		\/* Region max. *\/$/;"	m	struct:__db_mpool_stat
st_regmax	./include/db.h	/^	roff_t	  st_regmax;		\/* Region max. *\/$/;"	m	struct:__db_mutex_stat
st_regsize	./include/db.h	/^	roff_t	  st_regsize;		\/* Region size. *\/$/;"	m	struct:__db_lock_stat
st_regsize	./include/db.h	/^	roff_t	  st_regsize;		\/* Region size. *\/$/;"	m	struct:__db_log_stat
st_regsize	./include/db.h	/^	roff_t	  st_regsize;		\/* Region size. *\/$/;"	m	struct:__db_mpool_stat
st_regsize	./include/db.h	/^	roff_t	  st_regsize;		\/* Region size. *\/$/;"	m	struct:__db_mutex_stat
st_regsize	./include/db.h	/^	roff_t	  st_regsize;		\/* Region size. *\/$/;"	m	struct:__db_txn_stat
st_ro_evict	./include/db.h	/^	uintmax_t st_ro_evict;		\/* Clean pages forced from the cache. *\/$/;"	m	struct:__db_mpool_stat
st_rw_evict	./include/db.h	/^	uintmax_t st_rw_evict;		\/* Dirty pages forced from the cache. *\/$/;"	m	struct:__db_mpool_stat
st_scount	./include/db.h	/^	uintmax_t st_scount;		\/* Total syncs to the log. *\/$/;"	m	struct:__db_log_stat
st_site_participants	./include/db.h	/^	u_int32_t st_site_participants;	\/* # of repgroup participant sites. *\/$/;"	m	struct:__db_repmgr_stat
st_site_total	./include/db.h	/^	u_int32_t st_site_total;	\/* # of repgroup total sites. *\/$/;"	m	struct:__db_repmgr_stat
st_site_views	./include/db.h	/^	u_int32_t st_site_views;	\/* # of repgroup view sites. *\/$/;"	m	struct:__db_repmgr_stat
st_startsync_delayed	./include/db.h	/^	uintmax_t st_startsync_delayed;\/* # of STARTSYNC msgs delayed.+ *\/$/;"	m	struct:__db_rep_stat
st_startup_complete	./include/db.h	/^	u_int32_t st_startup_complete;	\/* Site completed client sync-up. *\/$/;"	m	struct:__db_rep_stat
st_status	./include/db.h	/^	u_int32_t st_status;		\/* Current replication status. *\/$/;"	m	struct:__db_rep_stat
st_sync_interrupted	./include/db.h	/^	uintmax_t st_sync_interrupted;	\/* Number of times sync interrupted. *\/$/;"	m	struct:__db_mpool_stat
st_tablesize	./include/db.h	/^	u_int32_t st_tablesize;		\/* Size of object hash table. *\/$/;"	m	struct:__db_lock_stat
st_takeovers	./include/db.h	/^	uintmax_t st_takeovers;		\/* # of automatic listener takeovers. *\/$/;"	m	struct:__db_repmgr_stat
st_time_ckp	./include/db.h	/^	time_t	  st_time_ckp;		\/* time of last checkpoint *\/$/;"	m	struct:__db_txn_stat
st_txnarray	./include/db.h	/^	DB_TXN_ACTIVE *st_txnarray;	\/* array of active transactions *\/$/;"	m	struct:__db_txn_stat
st_txns_applied	./include/db.h	/^	uintmax_t st_txns_applied;	\/* # of transactions applied.+ *\/$/;"	m	struct:__db_rep_stat
st_txntimeout	./include/db.h	/^	db_timeout_t st_txntimeout;	\/* Transaction timeout. *\/$/;"	m	struct:__db_lock_stat
st_value	./include/db.h	/^	db_seq_t  st_value;		\/* Current cached value. *\/$/;"	m	struct:__db_seq_stat
st_version	./include/db.h	/^	u_int32_t st_version;		\/* Log file version number. *\/$/;"	m	struct:__db_log_stat
st_view	./include/db.h	/^	u_int32_t st_view;		\/* Site is a view. *\/$/;"	m	struct:__db_rep_stat
st_w_bytes	./include/db.h	/^	u_int32_t st_w_bytes;		\/* Bytes to log. *\/$/;"	m	struct:__db_log_stat
st_w_mbytes	./include/db.h	/^	u_int32_t st_w_mbytes;		\/* Megabytes to log. *\/$/;"	m	struct:__db_log_stat
st_wait	./include/db.h	/^	uintmax_t st_wait;		\/* Sequence lock granted w\/o wait. *\/$/;"	m	struct:__db_seq_stat
st_waiting_lsn	./include/db.h	/^	DB_LSN st_waiting_lsn;		\/* LSN we're awaiting, if any. *\/$/;"	m	struct:__db_rep_stat
st_waiting_pg	./include/db.h	/^	db_pgno_t st_waiting_pg;	\/* pg we're awaiting, if any. *\/$/;"	m	struct:__db_rep_stat
st_wc_bytes	./include/db.h	/^	u_int32_t st_wc_bytes;		\/* Bytes to log since checkpoint. *\/$/;"	m	struct:__db_log_stat
st_wc_mbytes	./include/db.h	/^	u_int32_t st_wc_mbytes;		\/* Megabytes to log since checkpoint. *\/$/;"	m	struct:__db_log_stat
st_wcount	./include/db.h	/^	uintmax_t st_wcount;		\/* Total I\/O writes to the log. *\/$/;"	m	struct:__db_log_stat
st_wcount_fill	./include/db.h	/^	uintmax_t st_wcount_fill;	\/* Overflow writes to the log. *\/$/;"	m	struct:__db_log_stat
start_lsn	./include/db.h	/^	DB_LSN start_lsn, end_lsn;$/;"	m	struct:__db_logvrfy_config
start_time	./include/db.h	/^	time_t start_time, end_time;$/;"	m	struct:__db_logvrfy_config
stat	./include/db.h	/^	int		(*stat) __P((DB_SEQUENCE *,$/;"	m	struct:__db_sequence
stat	./include/db.h	/^	int  (*stat) __P((DB *, DB_TXN *, void *, u_int32_t));$/;"	m	struct:__db
stat_print	./include/db.h	/^	int		(*stat_print) __P((DB_SEQUENCE *, u_int32_t));$/;"	m	struct:__db_sequence
stat_print	./include/db.h	/^	int  (*stat_print) __P((DB *, u_int32_t));$/;"	m	struct:__db
stat_print	./include/db.h	/^	int  (*stat_print) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
status	./include/db.h	/^	u_int32_t status;		\/* Status of the transaction *\/$/;"	m	struct:__db_txn_active
status	./include/db.h	/^	u_int32_t status;$/;"	m	struct:__db_repmgr_site
storage	./storage_bdb.c	/^struct storage$/;"	s	file:
storage	./storage_mem.c	/^struct storage$/;"	s	file:
storage_close	./storage_bdb.c	/^storage_close(struct storage* s)   \/\/关闭数据库$/;"	f
storage_close	./storage_mem.c	/^storage_close(struct storage* s)$/;"	f
storage_get_max_iid	./storage_bdb.c	/^storage_get_max_iid(struct storage * s)$/;"	f
storage_get_record	./storage_bdb.c	/^storage_get_record(struct storage* s, iid_t iid) \/\/从数据库中获取记录$/;"	f
storage_get_record	./storage_mem.c	/^storage_get_record(struct storage* s, iid_t iid)$/;"	f
storage_open	./storage_bdb.c	/^storage_open(int acceptor_id)      \/\/打开一个数据库$/;"	f
storage_open	./storage_mem.c	/^storage_open(int acceptor_id)$/;"	f
storage_save_accept	./storage_bdb.c	/^storage_save_accept(struct storage* s, accept_req * ar)   \/\/accept_req  p2a,p->a  保存接受的请求$/;"	f
storage_save_accept	./storage_mem.c	/^storage_save_accept(struct storage* s, accept_req * ar)$/;"	f
storage_save_final_value	./storage_bdb.c	/^storage_save_final_value(struct storage* s, char* value, size_t size, $/;"	f
storage_save_final_value	./storage_mem.c	/^storage_save_final_value(struct storage* s, char* value, size_t size, $/;"	f
storage_save_prepare	./storage_bdb.c	/^storage_save_prepare(struct storage* s, prepare_req* pr, acceptor_record* rec)$/;"	f
storage_save_prepare	./storage_mem.c	/^storage_save_prepare(struct storage* s, prepare_req* pr, acceptor_record* rec)$/;"	f
storage_tx_begin	./storage_bdb.c	/^storage_tx_begin(struct storage* s)    \/\/创建一个新的事务$/;"	f
storage_tx_begin	./storage_mem.c	/^storage_tx_begin(struct storage* s)$/;"	f
storage_tx_commit	./storage_bdb.c	/^storage_tx_commit(struct storage* s)  \/\/提交事务$/;"	f
storage_tx_commit	./storage_mem.c	/^storage_tx_commit(struct storage* s)$/;"	f
store	./acceptor.c	/^	struct storage* store;$/;"	m	struct:acceptor	typeref:struct:acceptor::storage	file:
store	./include/db.h	2855;"	d
stored_close	./include/db.h	/^	int  (*stored_close) __P((DB *, u_int32_t));$/;"	m	struct:__db
stored_get	./include/db.h	/^	int  (*stored_get) __P((DB *, DB_TXN *, DBT *, DBT *, u_int32_t));$/;"	m	struct:__db
stqe_next	./include/db.h	/^		db_ssize_t stqe_next;$/;"	m	struct:__db_txn::__anon9
stqe_prev	./include/db.h	/^		db_ssize_t stqe_prev;$/;"	m	struct:__db_txn::__anon9
stqh_first	./include/db.h	/^		struct __txn_logrec *stqh_first;$/;"	m	struct:__db_txn::__anon11	typeref:struct:__db_txn::__anon11::__txn_logrec
stqh_last	./include/db.h	/^		struct __txn_logrec **stqh_last;$/;"	m	struct:__db_txn::__anon11	typeref:struct:__db_txn::__anon11::__txn_logrec
submit	./include/libpaxos_messages.h	/^	submit=32,          \/\/Clients to leader$/;"	e	enum:pax_msg_code_e
sync	./include/db.h	/^	int  (*sync) __P((DB *, u_int32_t));$/;"	m	struct:__db
sync	./include/db.h	/^	int (*sync) __P((DB_MPOOLFILE *));$/;"	m	struct:__db_mpoolfile
tail	./carray.c	/^	int tail;$/;"	m	struct:carray	file:
td	./include/db.h	/^	void		*td;		\/* Detail structure within region. *\/$/;"	m	struct:__db_txn
temp_envhome	./include/db.h	/^	const char *temp_envhome;$/;"	m	struct:__db_logvrfy_config
thr_init	./include/db.h	/^	u_int32_t	thr_init;	\/* Thread count *\/$/;"	m	struct:__db_env
thr_max	./include/db.h	/^	u_int32_t	thr_max;	\/* Thread max *\/$/;"	m	struct:__db_env
thread_id	./include/db.h	/^	void  (*thread_id) __P((DB_ENV *, pid_t *, db_threadid_t *));$/;"	m	struct:__db_env
thread_id_string	./include/db.h	/^	char *(*thread_id_string) __P((DB_ENV *, pid_t, db_threadid_t, char *));$/;"	m	struct:__db_env
thread_info	./include/db.h	/^	DB_THREAD_INFO	*thread_info;	\/* Pointer to thread information. *\/$/;"	m	struct:__db_txn
thread_info	./include/db.h	/^	DB_THREAD_INFO *thread_info;	\/* Thread that owns this cursor. *\/$/;"	m	struct:__dbc
tid	./include/db.h	/^	db_threadid_t tid;		\/* Thread owning txn ID *\/$/;"	m	struct:__db_txn_active
timeout	./include/db.h	/^	db_timeout_t	 timeout;	\/* Time to expire lock. *\/$/;"	m	struct:__db_lockreq
timeout	./include/db.h	/^	db_timeout_t timeout;$/;"	m	struct:__db_channel
timeout	./proposer.c	/^	struct timeval timeout;$/;"	m	struct:timeout_iterator	typeref:struct:timeout_iterator::timeval	file:
timeout_iterator	./proposer.c	/^struct timeout_iterator$/;"	s	file:
timeout_iterator_accept	./proposer.c	/^timeout_iterator_accept(struct timeout_iterator* iter)       \/\/迭代发送accept包$/;"	f
timeout_iterator_free	./proposer.c	/^timeout_iterator_free(struct timeout_iterator* iter)            \/\/释放迭代器$/;"	f
timeout_iterator_prepare	./proposer.c	/^timeout_iterator_prepare(struct timeout_iterator* iter)     \/\/超时请求，迭代准备$/;"	f
timestamp	./include/db.h	/^	time_t	 timestamp;		\/* Handle timestamp for replication. *\/$/;"	m	struct:__db
timeval_diff	./proposer.c	/^timeval_diff(struct timeval* t1, struct timeval* t2)   \/\/返回时间差$/;"	f	file:
token_buffer	./include/db.h	/^	DB_TXN_TOKEN	*token_buffer;	\/* User's commit token buffer. *\/$/;"	m	struct:__db_txn
tqe_next	./include/db.h	/^		DBC *tqe_next;	\/* next element *\/$/;"	m	struct:__dbc::__anon20
tqe_next	./include/db.h	/^		DBC *tqe_next;$/;"	m	struct:__dbc::__anon19
tqe_next	./include/db.h	/^		struct __db *tqe_next;$/;"	m	struct:__db::__anon14	typeref:struct:__db::__anon14::__db
tqe_next	./include/db.h	/^		struct __db *tqe_next;$/;"	m	struct:__db::__anon18	typeref:struct:__db::__anon18::__db
tqe_next	./include/db.h	/^		struct __db_mpoolfile *tqe_next;$/;"	m	struct:__db_mpoolfile::__anon6	typeref:struct:__db_mpoolfile::__anon6::__db_mpoolfile
tqe_next	./include/db.h	/^		struct __db_txn *tqe_next;$/;"	m	struct:__db_txn::__anon12	typeref:struct:__db_txn::__anon12::__db_txn
tqe_next	./include/db.h	/^		struct __db_txn *tqe_next;$/;"	m	struct:__db_txn::__anon8	typeref:struct:__db_txn::__anon8::__db_txn
tqe_prev	./include/db.h	/^		DBC **tqe_prev;	\/* address of previous next element *\/$/;"	m	struct:__dbc::__anon20
tqe_prev	./include/db.h	/^		DBC **tqe_prev;$/;"	m	struct:__dbc::__anon19
tqe_prev	./include/db.h	/^		struct __db **tqe_prev;$/;"	m	struct:__db::__anon14	typeref:struct:__db::__anon14::__db
tqe_prev	./include/db.h	/^		struct __db **tqe_prev;$/;"	m	struct:__db::__anon18	typeref:struct:__db::__anon18::__db
tqe_prev	./include/db.h	/^		struct __db_mpoolfile **tqe_prev;$/;"	m	struct:__db_mpoolfile::__anon6	typeref:struct:__db_mpoolfile::__anon6::__db_mpoolfile
tqe_prev	./include/db.h	/^		struct __db_txn **tqe_prev;$/;"	m	struct:__db_txn::__anon12	typeref:struct:__db_txn::__anon12::__db_txn
tqe_prev	./include/db.h	/^		struct __db_txn **tqe_prev;$/;"	m	struct:__db_txn::__anon8	typeref:struct:__db_txn::__anon8::__db_txn
tqh_first	./include/db.h	/^		DB *tqh_first;$/;"	m	struct:__db_txn::__femfs
tqh_first	./include/db.h	/^		struct __db_txn *tqh_first;$/;"	m	struct:__db_txn::__kids	typeref:struct:__db_txn::__kids::__db_txn
tqh_first	./include/db.h	/^		struct __dbc *tqh_first;$/;"	m	struct:__db::__cq_aq	typeref:struct:__db::__cq_aq::__dbc
tqh_first	./include/db.h	/^		struct __dbc *tqh_first;$/;"	m	struct:__db::__cq_fq	typeref:struct:__db::__cq_fq::__dbc
tqh_first	./include/db.h	/^		struct __dbc *tqh_first;$/;"	m	struct:__db::__cq_jq	typeref:struct:__db::__cq_jq::__dbc
tqh_first	./include/db.h	/^		struct __dbc *tqh_first;$/;"	m	struct:__db_txn::__my_cursors	typeref:struct:__db_txn::__my_cursors::__dbc
tqh_first	./include/db.h	/^		struct __txn_event *tqh_first;$/;"	m	struct:__db_txn::__anon10	typeref:struct:__db_txn::__anon10::__txn_event
tqh_last	./include/db.h	/^		DB **tqh_last;$/;"	m	struct:__db_txn::__femfs
tqh_last	./include/db.h	/^		struct __db_txn **tqh_last;$/;"	m	struct:__db_txn::__kids	typeref:struct:__db_txn::__kids::__db_txn
tqh_last	./include/db.h	/^		struct __dbc **tqh_last;$/;"	m	struct:__db::__cq_aq	typeref:struct:__db::__cq_aq::__dbc
tqh_last	./include/db.h	/^		struct __dbc **tqh_last;$/;"	m	struct:__db::__cq_fq	typeref:struct:__db::__cq_fq::__dbc
tqh_last	./include/db.h	/^		struct __dbc **tqh_last;$/;"	m	struct:__db::__cq_jq	typeref:struct:__db::__cq_jq::__dbc
tqh_last	./include/db.h	/^		struct __dbc **tqh_last;$/;"	m	struct:__db_txn::__my_cursors	typeref:struct:__db_txn::__my_cursors::__dbc
tqh_last	./include/db.h	/^		struct __txn_event **tqh_last;$/;"	m	struct:__db_txn::__anon10	typeref:struct:__db_txn::__anon10::__txn_event
truncate	./include/db.h	/^	int  (*truncate) __P((DB *, DB_TXN *, u_int32_t *, u_int32_t));$/;"	m	struct:__db
tx_init	./include/db.h	/^	u_int32_t	tx_init;	\/* Initial number of transactions *\/$/;"	m	struct:__db_env
tx_max	./include/db.h	/^	u_int32_t	tx_max;		\/* Maximum number of transactions *\/$/;"	m	struct:__db_env
tx_timeout	./include/db.h	/^	db_timeout_t	tx_timeout;	\/* Timeout for transactions *\/$/;"	m	struct:__db_env
tx_timestamp	./include/db.h	/^	time_t		tx_timestamp;	\/* Recover to specific timestamp *\/$/;"	m	struct:__db_env
txn	./include/db.h	/^	DB_TXN	 *txn;			\/* Associated transaction. *\/$/;"	m	struct:__dbc
txn	./include/db.h	/^	DB_TXN	*txn;$/;"	m	struct:__db_preplist
txn	./storage_bdb.c	/^	DB_TXN* txn;$/;"	m	struct:storage	file:
txn_applied	./include/db.h	/^	int  (*txn_applied) __P((DB_ENV *,$/;"	m	struct:__db_env
txn_begin	./include/db.h	/^	int  (*txn_begin) __P((DB_ENV *, DB_TXN *, DB_TXN **, u_int32_t));$/;"	m	struct:__db_env
txn_checkpoint	./include/db.h	/^	int  (*txn_checkpoint) __P((DB_ENV *, u_int32_t, u_int32_t, u_int32_t));$/;"	m	struct:__db_env
txn_cursors	./include/db.h	/^	} txn_cursors;$/;"	m	struct:__dbc	typeref:struct:__dbc::__anon20
txn_list	./include/db.h	/^	void		*txn_list;	\/* Undo information for parent. *\/$/;"	m	struct:__db_txn
txn_recover	./include/db.h	/^	int  (*txn_recover) __P((DB_ENV *,$/;"	m	struct:__db_env
txn_stat	./include/db.h	/^	int  (*txn_stat) __P((DB_ENV *, DB_TXN_STAT **, u_int32_t));$/;"	m	struct:__db_env
txn_stat_print	./include/db.h	/^	int  (*txn_stat_print) __P((DB_ENV *, u_int32_t));$/;"	m	struct:__db_env
txnid	./include/db.h	/^	u_int32_t	txnid;		\/* Unique transaction id. *\/$/;"	m	struct:__db_txn
txnid	./include/db.h	/^	u_int32_t txnid;		\/* Transaction ID *\/$/;"	m	struct:__db_txn_active
type	./include/db.h	/^	DBTYPE	 type;			\/* DB access method type. *\/$/;"	m	struct:__db
type	./include/db.h	/^	log_rec_type_t	type;$/;"	m	struct:__log_rec_spec
type	./include/db.h	/^	u_int32_t type;			\/* Type of lock. *\/$/;"	m	struct:__db_ilock
type	./include/libpaxos_messages.h	/^	paxos_msg_code type;$/;"	m	struct:paxos_msg_t
ulen	./include/db.h	/^	u_int32_t ulen;			\/* RO: length of user buffer. *\/$/;"	m	struct:__db_dbt
upgrade	./include/db.h	/^	int  (*upgrade) __P((DB *, const char *, u_int32_t));$/;"	m	struct:__db
value	./include/libpaxos_messages.h	/^	char value[0];$/;"	m	struct:accept_ack_t
value	./include/libpaxos_messages.h	/^	char value[0];$/;"	m	struct:accept_req_t
value	./include/libpaxos_messages.h	/^	char value[0];$/;"	m	struct:prepare_ack_t
value	./proposer.c	/^	paxos_msg* value;$/;"	m	struct:instance	file:
value_ballot	./include/libpaxos_messages.h	/^	ballot_t value_ballot;$/;"	m	struct:accept_ack_t
value_ballot	./include/libpaxos_messages.h	/^	ballot_t value_ballot;$/;"	m	struct:prepare_ack_t
value_ballot	./proposer.c	/^	ballot_t value_ballot;$/;"	m	struct:instance	file:
value_size	./include/libpaxos_messages.h	/^	size_t value_size;$/;"	m	struct:accept_ack_t
value_size	./include/libpaxos_messages.h	/^	size_t value_size;$/;"	m	struct:accept_req_t
value_size	./include/libpaxos_messages.h	/^	size_t value_size;$/;"	m	struct:prepare_ack_t
values	./proposer.c	/^	struct carray* values;         \/\/要接受的值的队列$/;"	m	struct:proposer	typeref:struct:proposer::carray	file:
verbose	./include/db.h	/^	int continue_after_fail, verbose;$/;"	m	struct:__db_logvrfy_config
verbose	./include/db.h	/^	u_int32_t	verbose;	\/* DB_VERB_XXX flags *\/$/;"	m	struct:__db_env
verbosity	./include/paxos.h	/^	int verbosity;$/;"	m	struct:paxos_config
verify	./include/db.h	/^	int  (*verify)$/;"	m	struct:__db
version	./include/db.h	/^	int (*version) __P((DB_LOGC *, u_int32_t *, u_int32_t));$/;"	m	struct:__db_log_cursor
wrap_value	./proposer.c	/^wrap_value(char* value, size_t size)    \/\/将value包装成paxos_msg$/;"	f	file:
write	./include/db.h	/^	int  (*write) __P((DB_STREAM *, DBT *, db_off_t, u_int32_t));$/;"	m	struct:__db_stream
xa_links	./include/db.h	/^	} xa_links;			\/* Links XA transactions. *\/$/;"	m	struct:__db_txn	typeref:struct:__db_txn::__anon9
xa_status	./include/db.h	/^	u_int32_t xa_status;		\/* XA status *\/$/;"	m	struct:__db_txn_active
xa_thr_status	./include/db.h	/^	u_int32_t	xa_thr_status;$/;"	m	struct:__db_txn
xml_internal	./include/db.h	/^	void	*xml_internal;		\/* XML API private. *\/$/;"	m	struct:__db_txn
